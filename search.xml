<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vim实用技巧</title>
      <link href="/2021/12/02/Vim%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2021/12/02/Vim%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="vim解决问题的思想"><a class="markdownIt-Anchor" href="#vim解决问题的思想"></a> vim解决问题的思想</h2><p>我们的工作是重复性的。不论是在几个不同的地方做相同的小改动还是在文档的相似结构间移动,我们都会重复很多操作。凡是可以简化重复性操作的方式,都会成倍地节省我们的时间。</p><p>Vim对重复性操作进行了优化。它之所以能高效地重复,是因为它会记录我们最近的操作,让我们用一次按键就能重复上次的修改。</p><h2 id="技巧一-命令"><a class="markdownIt-Anchor" href="#技巧一-命令"></a> 技巧一 <code>.</code>命令</h2><p><code>.</code>命令可以让我们重复上次的修改,它是Vim中最为强大的多面手</p><p>要理解<code>.</code>命令的强大,我们需要意识到这一点:“上次修改”可以指很多东西, 次修改的单位可以是字符、整行,甚至是整个文件。</p><p><code>x</code>命令会删除光标下的字符,在这种情况下使用、命令<code>.</code>“重复上次修改”时,就会让Vim删除光标下的字符。</p><p><code>d</code>命令也做删除操作,但它会把整行一起删掉。如果在<code>d</code>后使用、命令,那么重复上次修改”会让Vim删除当前行。</p><p><code>&gt;G</code>命令会增加从当前行到文档末尾处的缩进层级。如果我们在此命令后使用<code>.</code>命令,那么“重复上次修改”会让Vim增加从当前行到文档末尾的缩进层级。</p><p><code>x</code>、<code>dd</code>以及<code>&gt;G</code>命令都是在普通模式中执行的命令,不过,每次我们进入插入模式时,也会形成一次修改。从进入插入模式的那一刻起(例如,输入i),直到返回普通模式时为止(输入<code>&lt;Esc&gt;)</code>,Vim会记录每一个按键操作。做出这样一个修改后再用命令的话,它将会重新执行所有这些按键操作。</p><p><code>.</code>命令是一个微型的宏。</p><h2 id="技巧二-不要自我重复"><a class="markdownIt-Anchor" href="#技巧二-不要自我重复"></a> 技巧二 不要自我重复</h2><p><img src="https://i.loli.net/2021/12/03/5Jc8AFwx4IoLsBd.png" alt="image-20211203190649932" loading="lazy"></p><p>我们想在每行的结尾添加一个分号。</p><p><strong><code>a</code>命令在当前光标之后添加内容</strong>,<strong>而<code>A</code>命令则在当前行的结尾添加内容。不管光标当前处于什么位置,输入<code>A</code>都会进入插入模式,并把光标移到行尾。换句话说,它把<code>$a</code>封装成了一个按键操作。</strong></p><p>我们通过用<code>A</code>来代替<code>a</code>,大大提升了<code>.</code>命令的效率。我们不必再把光标移到行尾,只需保证它位于该行内就行了(可在任意位置)。现在我们可以重复执行足够多次的使用<code>j.</code>,完成对后续行的修改。</p><h2 id="技巧三-以退为进"><a class="markdownIt-Anchor" href="#技巧三-以退为进"></a> 技巧三 以退为进</h2><blockquote><p>我们可以用一种常用的Vim操作习惯在一个字符前后各添加一个空格。乍一看这种方法有点古怪,不过其好处是可重复,这将使我们可以事半功倍地完成工作。</p></blockquote><p><img src="https://i.loli.net/2021/12/03/6qtLiDk2UNAPXEB.png" alt="image-20211203191031927" loading="lazy"></p><p>在 Javascript里把字符串连接到一起从来都不美观,但我们可以像下面这样在+ 号前后各添加一个空格,让肉眼更容易识别。</p><ul><li><strong><code>s</code>命令把两个操作合并为一个: 它先删除光标下的字符,然后进入插入模式</strong></li><li>在删除+号后,我们先输入__  +  __,然后退出插入模式。</li><li>我们可以用<code>.</code>命令重复这一修改。我们所要做的只是把光标移到下一个+号处,然后用命令重复这一操作即可。</li><li>完成第一处修改后,我们可以重复按**<code>f+</code>命令跳到下一个+号所在的位置。<strong>不过,     还有一种更好的方法可以用。</strong><code>;</code>命令会重复査找上次<code>f</code>命令所找的字符**,因此我们用不着输入4次<code>f+</code>,而是只用输入一次,后面跟着再用3次;命令。</li></ul><h2 id="技巧四-执行-重复-回退"><a class="markdownIt-Anchor" href="#技巧四-执行-重复-回退"></a> 技巧四    执行、重复、回退</h2><blockquote><p>在面对重复性工作时,我们需要让移动动作和修改都能够重复,这样就可以达到个最佳编辑模式。</p></blockquote><p><strong>在你不小心做过头时,知道怎么回退会很有帮助。</strong></p><p><img src="https://i.loli.net/2021/12/03/eZnBX4UvK7EtuWF.png" alt="image-20211203192115464" loading="lazy"></p><p>技巧五   査找并手动替换</p><p>在下面这段文本中,每一行都出现了单词“ content”</p><p><img src="https://i.loli.net/2021/12/03/fsUTkcIzpRvGMyb.png" alt="image-20211203192610831" loading="lazy"></p><p>假设我们想用单词“copy”(意义同“ copywriting”)来替代“ content</p><p><strong>利用<code>*</code>命令,此命令可以查找当前光标下的单词。我们只要将光标移动到单词上，<code>*</code>命令就会自动查找该光标下的单词，按<code>*</code> or <code>n</code>or  <code>N</code>可以切换到下一个单词。</strong></p><p>当光标位于“content”的开头时,我们就可以着手修改它。这包括两步操作:首先要删除单词“ content”,然后输入替代的单词。<strong><code>cw</code>命令会删除从光标位置到单词结尾间的字符,并进入插入模式</strong>,接下来我们就可以输入单词“copy”了。<strong>Vim会把我们离开插入模式之前的全部按键操作都记录下来</strong>,因此整个 **<code>cwcopy&lt;Ese&gt;</code>会被当成一个修改。也就是说,执行<code>.</code>命令会删除从光标到当前单词结尾间的字符,并把它修改为“copy。**每次我们按<code>n</code>键时,光标就会跳到下一个“ content”单词所在之处, 而当我们按键时,它就会把光标下的单词改为“copy。</p><h2 id="技巧六-结识范式"><a class="markdownIt-Anchor" href="#技巧六-结识范式"></a> 技巧六   结识<code>.</code>范式</h2><p>我们上面说了那么多例子，都用到了<code>.</code>命令，这些例子都有一个共同点：</p><p>它们都只需要按一次键就能把光标移到下一个目标上。</p><p><strong>用一次按键移动,另一次按键执行</strong>,没有再比这更好的了,不是吗?这就是我的理想解決方案。我们将会一次又一次地看到这一编辑模式,所以为了方便起见,我们把它叫做“<code>.</code>范式”</p><h2 id="技巧七-停顿时请移开画笔"><a class="markdownIt-Anchor" href="#技巧七-停顿时请移开画笔"></a> 技巧七  停顿时请移开画笔</h2><p>你估计画家会花费多少时间用画笔在画布上作画?毫无疑问,这因人而异,但是如果这占了画家全部工作时间的一半还要多的话,我会觉得非常诧异想一下除了画画外,画家还要做哪些事情。他们要研究主题,调整光线,把料混合成新的色彩。而且,在把颜料往画布上画时,谁说他们必须要用画笔?画家也许会换用刻刀来实现不同的质地,或是用棉签来对已经画好的地方进行润色。<br><strong>画家在休息时不会把画笔放在画布上。对Vim而言也是这样,普通模式就是Vin 的自然放松状态,其名字已经寓示了这一点。</strong><br>就像画家只花一小部分时间涂色一样**,程序员也只花一小部分时间编写代码。绝大多数时间用来思考、阅读,以及在代码中穿梭浏览。而且,当确实需要做修改时,     谁说一定要切换到插入模式オ行?我们可以重新调整已有代码的格式,复制它们,移动其位置,或是删除它们。在普通模式中,我们有众多的工具可以利用。**</p><h2 id="技巧八-把撤销单元切成块"><a class="markdownIt-Anchor" href="#技巧八-把撤销单元切成块"></a> 技巧八   把撤销单元切成块</h2><blockquote><p>在Vim中,我们自己可以控制撤销命令的粒度。从进入插入模式开始,直到返回普通模式为止,在此期间输入或删除的任何内容都被当成一次修改。因此,只要我们控制好对<Esc>键的使用,就可使撤销命令作用于单词、句子或段落。</Esc></p></blockquote><p>那么,应该多久离开一次插入模式呢?这是个人喜好的问题,不过我喜欢<strong>让每个可撤销块”对应一次思考过程。</strong></p><p><strong>我经常在每句话的结尾停顿一下,想一想接下来该写什么。不管停顿的时间有多短,每次停顿都是一个自然的中断点,提示我该退出插入模式了</strong>。当我准备好继续写时,按A命令就可以回到原来的地方继续写作。</p><p><strong>当处于插入模式时,如果光标位于行尾的话,另起一行最快的方式是按<code>&lt;CR&gt;</code>。不过有时我更喜欢按<code>&lt;Esc&gt;o,</code>这是因为我有预感,也许在撤销时我想拥有更细的粒度</strong>如果听起来这不太好理解,不必担心,当你对Vim越来越熟悉时,就会感到切换模式越来越轻松。</p><blockquote><p>在插入模式中移动光标会重置修改状态</p><p>当我提到撤销命令会回退从进入插入模式到退出此模式期间输入(或删除)的全部字符时,我略过了一个小细节。如果在插入模式中使用了<up>、<Down>、&lt; Left&gt; 或&lt; Right&gt;这些光标键,将会产生一个新的撤销块。你可以把这想象为先切换回普通模式,然后用h、j、k或l命令对光标进行了移动,唯一区别是我们并没有退出插入模式。这也会对.命令的操作产生影响。</Down></up></p></blockquote><h2 id="技巧九-构造可重复的修改"><a class="markdownIt-Anchor" href="#技巧九-构造可重复的修改"></a> 技巧九    构造可重复的修改</h2><blockquote><p>Vim对重复操作进行了优化,要利用这一点,我们必须考虑该如何构造修改</p></blockquote><p><strong>在Vim中,要完成一件事,总是有不止一种方式。在评估哪种方式最好时,最显而易见的指标是效率,即哪种手段需要的按键次数最少。</strong></p><p>在下例中,假设光标位于行尾处的字符“h”上,而我们想要删除单词“nigh”</p><p><img src="https://i.loli.net/2021/12/03/tmxjJSMpGweV4uh.png" alt="image-20211203195546905" loading="lazy"></p><p>因为光标已经位于单词末尾,我们可以先<strong>反向删除</strong>该词</p><p>按<code>db</code>命令删除从光标起始位置到单词开头的内容,但会原封未动地留下最后个字符“h”,再按一下<code>x</code>键就可以删除这个捣乱的字符。这样,整个操作的Vim高尔夫得分是3分。</p><p>这一次,让我们尝试一下<strong>正向删除</strong></p><p>我们先用<code>b</code>命令把光标移到单词的开头,移动好后,就可以用一个<code>dw</code>命令删掉整个单词。这一次的Vim高尔夫得分也是3分</p><p>到目前为止,已有的两种方式都要先做某种准备工作或清理工作。另外,我们也可以<strong>使用更为精准的<code>aw</code>文本对象( text object),而不是用动作命令</strong></p><p>你可以把<code>daw</code>命令解读为“ delete a word”,这样比较容易记忆。</p><p><strong>哪种方式最好?</strong></p><blockquote><p>在操作后跟<code>.</code>命令</p></blockquote><p>反向删除方案包含两步操作:db命令删除至单词的开头,而后命令删除一个字符。如果我们眼着执行一次命令,它会重复删除一个字符(,=)。我不得这有什么价值。</p><p>正向删除方案也包含两步。这一次,b只是一次普通的移动,而w完成修改  此时用<code>.</code>命令会重复<code>w</code>,删除从光标位置到下个单词开头的内容。不过因为我们刚好已经在行尾了,并没有“下一个单词”,所以在这个场景里命令没什么用。不过,     至少它代表了个更长点的操作(.==dw)。</p><p>最后的方案只调用一个操作:<code>daw</code>。这个操作不仅仅删除了该单词,它还会删除个空格,因此光标最终会停在单词“is”的最后一个字符上。如果此时我们使用<code>.</code>命令,它会重复上次删除单词的命令。这一次,命令会做真正有用的事情(=daw)。</p><p>要想充分利用命令,事先常常需要进行一番周详的考虑。如果你发现自己要在几个地方做同样的小修改,就可以尝试构造你的修改,让它们能够被<code>.</code>命令重复执行。<br>要识别出这类机会需要进行一定的实践,不过一且你养成了使修改可重复的习惯,那么你就会从Vim这里得到“奖赏。</p><h2 id="技巧十-用次数做简单的算术运算"><a class="markdownIt-Anchor" href="#技巧十-用次数做简单的算术运算"></a> 技巧十   用次数做简单的算术运算</h2><p><strong><code>&lt;C-a&gt;</code>和<code>&lt;C-x&gt;</code>命令分别对数字执行加和减操作。在不带次数执行时,它们会逐个加减,但如果带一个次数前缀,那么就可以用它们加减任意整数。例如,如果我们把光标移到字符5上,执行<code>10&lt;C-a&gt;</code>就会把它变成15。</strong></p><p>但是如果光标不在数字上会发生什么?文档里说,<code>&lt;C-a&gt;</code>命令会“把当前光标之上或之后的数值加上[     count”(参见: h ctrl-a)。**因此,如果光标不在数字上,     那么<code>&lt;C-a&gt;</code>命令将在当前行正向査找一个数字,如果找到了,它就径直跳到那里。**我们可以利用这一点简化操作。</p><p>下面是一段CSS片段</p><p><img src="https://i.loli.net/2021/12/03/HxjlM9XFnoyhNIi.png" alt="image-20211203200701976" loading="lazy"></p><p><strong>我们要复制最后一行并且对其做两个小改动,即用“news”替换单词“blog”,以及把“0px”改为“-180px”。</strong> **我们可以运行<code>yyp</code>来复制此行,然后用<code>cw</code>来修改第个单词。**但我们该怎么处理那个数值呢?</p><p><strong>一种做法是用<code>f0</code>跳到此数字,然后进入插入模式手动修改它的值,即<code>i-180&lt;Esc&gt;</code>。</strong></p><p><strong>运行180<code>&lt;C-x&gt;</code>则要快得多。由于我们的光标不在要操作的数字上,所以该命令会正向跳到所找到的第一个数字上,从而省去了手动移光标的步骤。</strong></p><p>在本例中,我们只复制了一行并做出改动。但是,假设你要复制10份,并对后续数字依次减180。如果要切换到插入模式去修改每个数字,我们每次都得输入不同的内容(-180,然后-360,以此类推)。但是如果用180<c-x>命令的话,对后续行也可以采用相同的操作过程</c-x></p><p>技巧十一     能够重复,就別用次数</p><blockquote><p>在处理某些特定工作时,使用次数可以使按键次数变得最少,不过我们并不是非得这样不可。我们需要认真考虑次数与重复各自的优缺点</p></blockquote><p>假设在缓冲区里有如下文字</p><p><img src="https://i.loli.net/2021/12/03/EHB3q9poVgawmJs.png" alt="image-20211203201613823" loading="lazy"></p><p>我们想把这段文字改为“ Delete one word”,也就是说,要像这段文字里所讲的那样删除两个单词。</p><p>有几种方式可以达到这一目的,<code>d2w</code>和<code>2dw</code>都可以。<strong>使用<code>d2w</code>,我们先调用删除命令,然后以<code>2w</code>作为动作命令,我们可以把它解读为“删除两个单词”;然而<code>2dw</code>做的相反,这一次,次数作用于删除命令,而动作命令只跨越一个单词,我们可以把这解读为“做两次删除单词的操作”。抛开语义不讲,无论哪种方法,结果都是相同</strong></p><p>根据我们的讨论,<code>d2w</code>和<code>2dw</code>是相同的,在执行完两者中的任一个后,我们可以按键撤销,这样两个被删除的单词又会回来。或者,我们不是用撤销,而是用命令重复执行它,这就会删除后面的两个单词。</p><p>**对于<code>dw.</code>的情形,按或的结果会有细微的差别。这里的修改是<code>dw</code>,即删除个单词。因此,如果想恢复这两个被删除的单词,必须撤销两次,按<code>u</code>(或者,如果你愿意,也可以按<code>2u</code>)。**按、则只删除后面的一个单词,而不是两个现在假设我们原本是想删除3个单词,而不是2个。由于判断出了点差错,我们执行了<code>d2w</code>而不是<code>d3w</code>,那接下来怎么做?我们不能使用命令,因为那会总共删除4     个单词。因此,我们或是先撤销而后修正次数(<code>ud3w</code>),或是继续删除下一个单词(<code>dw</code>)     现在考虑另一种方案,如果我们在第一处地方用的是dw.命令,那么我们只要再多重复一次命令就行了。因为我们最初的修改只是简单的<code>dw</code>,因此命令和,命令都具有更细的粒度,每次只作用于一个单词。<br>现在假设我们想删除7个单词,我们可以运行d7,或是dw…(即dw后面跟6次命令)。计算一下按键的次数,哪个命令胜出是很显而易见的。不过你真地确信自己数对了次数吗?     计算次数很是讨厌,因此我宁愿按6次.命令,也不愿意只为减少按键的次数,     而浪费同样的时间去统计次数。如果我多按了一次.命令怎么办?没关系,只要按次键就可以回退回来。</p><blockquote><p>只在必要时使用次数</p></blockquote><blockquote><p>假设我们想把文字“     I have a couple of questions”改为 I have some more questions”, 可以用下面的方式做</p></blockquote><p>在此场景中,使用.命令的意义不大**,我们可以删除一个单词,然后再用.命令删除另一个,但随后我们还得切换到插入模式(例如,使用<code>i</code>或<code>cw</code>)。对我来说这么做很不顺手,我反而更愿意用次数。**<br><strong>使用次数的另一个好处是:它保留了一个干净、连贯的撤销历史记录。完成这次修改后,我们按一下键就可以撤销整个修改,这和技巧8中的讨论是一致的。</strong></p><h2 id="技巧十二-双剑合壁天下无敌"><a class="markdownIt-Anchor" href="#技巧十二-双剑合壁天下无敌"></a> 技巧十二    双剑合壁,天下无敌</h2><blockquote><p>操作符+动作命令=操作</p></blockquote><p><strong>demotion</strong>命令可以对**一个字符(d)、一个完整单词(daw)或一整个段落(dap) 进行操作,它作用的范围由动作命令决定。**c{ motion)}、y{ motion}以及其他一些命令也类似,它们被统称为操作符( operator)。</p><p><strong><code>g-</code>、<code>gu</code>和<code>gU</code>命令要用两次按键来调用,我们可以把上述命令中的g当做一个前缀字符,用以改变其后面的按键行为</strong></p><p>操作符与动作命令的结合形成了一种语法。这种语法的第一条规则很简单**,即一个操作由一个操作符,后面跟一个动作命令组成**</p><img src="https://s2.loli.net/2021/12/04/Oo1XmuLrEdtksFK.png" alt="image-20211204101313080" style="zoom:80%;" loading="lazy"><h2 id="技巧十三在插入模式中可即时更正错误"><a class="markdownIt-Anchor" href="#技巧十三在插入模式中可即时更正错误"></a> 技巧十三在插入模式中可即时更正错误</h2><blockquote><p>如果在插入模式下撰写文本时出了错,我们可以立刻对它进行更正,而无需切换模式。要迅速更正错误,除了用退格键外,我们还可以用插入模式中的其他一些命令</p></blockquote><p><strong>你也可以切换到普通模式,然后跳到这个词的开头并更正错误,再按A返回刚才的位置。不过完成这一套动作要花的时间可能不止1秒钟</strong>,并且它也无助于提高你的盲打技巧。虽然说我们可以切换模式,不过这并不意味着一定就得切换。</p><p><img src="https://s2.loli.net/2021/12/04/QmzMuExrkX6pYvq.png" alt="image-20211204101606890" loading="lazy"></p><h2 id="技巧十四返回普通模式"><a class="markdownIt-Anchor" href="#技巧十四返回普通模式"></a> 技巧十四返回普通模式</h2><p>结识插入-普通模式</p><blockquote><p>插入-普通模式是普通模式的一个特例,它能让我们执行一次普遍模式命令。**在此模式中,我们可以执行一个普通模式命令,执行完后,马上就又返回到插入模式。**要从插入模式切换到插入-普通模式,可以按<code>&lt;C-o&gt;</code></p></blockquote><p>在当前行正好处于窗口顶部或底部时,有时我会滚动一下屏幕,以便看到更多的上下文。**用<code>zz</code>命令可以重绘屏幕,并把当前行显示在窗口正中,这样就能够阅读当前行之上及之下的半屏内容。我常常会键入<code>C-o&gt;</code>,在插入-普通模式中触发这条命令。**此操作完成后就会直接回到插入模式,因此我可以不受中断地继续打字</p><h2 id="技巧十五随时随地做运算"><a class="markdownIt-Anchor" href="#技巧十五随时随地做运算"></a> 技巧十五随时随地做运算</h2><p>我们可以用<code>=</code>符号指明使用表达式寄存器。在插入模式中,输入<code>&lt;C-r&gt;</code>=就可以访问这一寄存器。这条命令会在屏幕的下方显示一个提示符,我们可以在其后输入要执行的表达式。输入表达式后敲一下<code>&lt;CR&gt;</code>,Vim就会把执行的结果插入到文档的当前位置了。</p><h2 id="技巧十六选择高亮选区"><a class="markdownIt-Anchor" href="#技巧十六选择高亮选区"></a> 技巧十六选择高亮选区</h2><p><img src="https://s2.loli.net/2021/12/04/lFdWbIU34hAuK9Y.png" alt="image-20211204102259444" loading="lazy"></p><p><strong><code>gv</code>命令是个有用的快捷键,它用来重选上一次由可视模式所选择的文本范围。不管上个选区是面向字符的、面向行的,或是面向列块的,v命令都能够正确地工作。</strong></p><blockquote><p>不过如果上次的选区被删除了,它也许会工作得不太正常。</p></blockquote><p>在可视模式间切换</p><p><img src="https://s2.loli.net/2021/12/04/FykuRGV7IXCeH2N.png" alt="image-20211204102420481" loading="lazy"></p><p>切换选区的活动端</p><p>高亮选区的范围由其两个端点界定。其中一端固定,而另一端可以随光标自由移动,我们可以用。**<code>o</code>键来切换其活动的端点。在定义选区时,如果定义到一半时, 才发现选区开始的位置不对,此时用这个键会很方便,我们用不着退出可视模式再从头开始,只需按一下<code>o</code>,然后重新调整选区的边界即可。**下面的操作对此功能进行了演示:</p><p><strong>技巧十七重复执行面向行的可视命令</strong></p><p>**当使用<code>.</code>命令重复对高亮选区所做的修改时,此修改会重复作用于相同范围的文本。**在本节中,我们会对一个面向行的高亮选区做一个修改,然后使用<code>.</code>命令重复此修改。</p><p><strong>在可视模式中执行完一条命令后,我们就会返回到普通模式,并且在可视模式里所选中的文本范围也不再高亮显示了。那么,如果我们想对相同范围的文本执行另外条可视模式命令,该怎么办?</strong></p><p>假设有一段 Python代码的缩进有些问题,如下所示</p><p><img src="https://s2.loli.net/2021/12/04/KvpxL2FIlwQ5XqA.png" alt="image-20211204103157694" loading="lazy"></p><p>先缩进一次,然后重复</p><p><strong>在这段缩进错误的 Python代码中, while关键字下面的两行应该多缩进两级。我们可以高亮选择这两行,然后用命令对它进行缩进,以修正其缩进错误。但此操作只增加一级缩进就返回普通模式了</strong></p><p><strong>要解决此问题,一个办法是使用<code>gv</code>命令重选相同的文本,然后再次调用缩进命令</strong></p><p>然而,如果你已经对Vim解决问题的方式有所领悟的话,你脑海里应该会响起警钟</p><p>如果你已经对Vim解决问题的方式有所领悟的话,你脑海里应该会响起警钟当需要执行重复操作时,<code>,</code>命令是最佳的解决方案。与其手动重选相同范围的文本并执行相同的命令,倒不如直接在普通模式里按键。</p><h2 id="技巧二十三只要可能最好用操作符命令而不是可视命令"><a class="markdownIt-Anchor" href="#技巧二十三只要可能最好用操作符命令而不是可视命令"></a> 技巧二十三只要可能,最好用操作符命令,而不是可视命令</h2><blockquote><p>假设我们想把下面列表中的链接文字转换为大写格式</p></blockquote><p><img src="https://s2.loli.net/2021/12/04/V2hOuldwngHAF6X.png" alt="image-20211204122856713" loading="lazy"></p><p><strong>我们可以用<code>vit</code>来选择标签里的内容。<code>vit</code>可被解读为高亮选中标签内部的内容( visually select inside the tag),其中,<code>it</code>命令是一种被称为文本对象( text object)</strong></p><p><strong>本例中,我们可以使<code>gU</code>用命令来把所选中的字符转换为大写</strong></p><p><strong>在转换完第一行后,现在我们想对接下来的两行进行同样的修改。用点范式试下吧,怎么样?</strong></p><p><strong>好,我们执行一下<code>j.</code>命令,把光标移到下一行并重复上次的修改。此命令在第二行工作得很好,但如果我们再执行一次,最终就会得到这个看起来有点古怪的结果</strong></p><p><img src="https://s2.loli.net/2021/12/04/VqHus6PFwJocx4B.png" alt="image-20211204131801323" loading="lazy"></p><p>你看到发生什么了吗?当一条可视模式命令被重复执行时,它会影响相同数量的文本。在本例中,最初的命令影响了一个由3个字母组成的单词。</p><p><strong>使用普通模式下的操作符命令</strong></p><p>可视模式下的命令有一个等效的普通模式命令 <code>gu&#123;motion&#125;</code></p><p>这两种方式都只需要4次按键操作:vit及guit,但其背后的含义却大相径庭在可视模式所采用的方式里,这4次按键可以被当做两个独立的命令。vit用来选中选区,而U用来对选区进行转换。与之相反的是,guit命令可以被当成一个单独的命令,它由一个操作符(<code>gU</code>)和一个动作命令<code>(it</code>)组成。</p><p>如果<strong>我们想使点命令能够重复某些有用的工作,那么最好要远离可视模式</strong>。作为一般的原则,在做一系列可重复的修改时,最好首选操作符命令,而不是其对应的可视模式命令。</p><h2 id="技巧二十四用面向列块的可视模式辑表格数据"><a class="markdownIt-Anchor" href="#技巧二十四用面向列块的可视模式辑表格数据"></a> 技巧二十四用面向列块的可视模式辑表格数据</h2><p>假设有如下一个纯文本表格</p><p><img src="https://s2.loli.net/2021/12/04/GrXyLWn58QKslDC.png" alt="image-20211204133320583" loading="lazy"></p><p>我们想用管道符画一条竖线来隔开这两列文本,使之看起来更像一个表格。但是在此之前,要先减少两列之间的间隔,使它们不要分得这么开。用面向列块的可视模式可以完成这两处修改</p><p>开始,我们先使用<code>&lt;C-V&gt;</code>进入列块可视模式,然后向下移动几行光标,选中一列文本。接下来,按<code>x</code>键删除此列,并用.命令重复删除相同范围的文本,多重复几次直到距右边差不多有两列的距离我们也可以不用命令,而是把光标向右移动两三次,把列选区扩展为块选区, 而后只需删除一次即可。不过,我更喜欢在删除时看到即时的视觉反馈,然后再多次重复此操作现在,我们已经把所需的两列文本排列到了合适的位置,接下来就可以在这两列文本间画一条竖线了。我们先用<code>gv</code>命令重选上次的高亮选区,然后输入<code>rl</code>,用管道符替换此选区内的字符。1</p><h2 id="技巧二十五修改列文本"><a class="markdownIt-Anchor" href="#技巧二十五修改列文本"></a> 技巧二十五修改列文本</h2><p>例如,对于以下CSS片段</p><p><img src="https://s2.loli.net/2021/12/04/w5jVJfprqX8m1ZI.png" alt="image-20211204133428056" loading="lazy"></p><p>假设我们已经把文件     sprite.png从 Images/目录移到了     components/目录,那么就需要修改每一行的内容,使其指向该文件的新位置。我们可以使用列块可视模式完成此工作</p><p>整个过程看起来非常熟悉。先指定想要操作的选区,本例中的高亮选区恰好为方形。当我们按<code>c</code>键时,所有被选中的文本都消失了,同时我们进入了插入模式。</p><p><strong>当我们在插入模式中输入单词“ components”时,此单词只出现在顶行,下面的两行没什么变化。只有在按了&lt;Esc返回到普通模式后,我们才看到刚才输入的文本出现在下面这两行里。</strong></p><p>在Vim列块可视模式中,修改命令的表现或许有点怪,它看上去有点不一致除操作会同时影响所有被选中的行,但插入操作只影响顶行(至少在处于插入模式的期间)。其他文本编辑器也提供了类似的功能,但是它们会同时更新所有被选中的行,如果你已经习惯了这样的表现(就像我以前一样),那么你会发现Vim的实现不太完美</p><p>不过在实践中,最终的结果没什么区别。因为你处于插入模式的时间很短,所以没必要太过惊讶</p><h2 id="技巧二十六在长短不一的高亮块后添加文本"><a class="markdownIt-Anchor" href="#技巧二十六在长短不一的高亮块后添加文本"></a> 技巧二十六在长短不一的高亮块后添加文本</h2><p>我们已经见过以下的 Javascript代码片段</p><p><img src="https://s2.loli.net/2021/12/04/BQZRKc7Dak9I8lb.png" alt="image-20211204133614110" loading="lazy"></p><p>这段代码有连续3行,每行的长度各不相同,而我们想在每行结尾添加一个分号在技巧2中,我们使用命令解决了此问题,不过,用列块可视模式也可以完成该任务</p><p>在进入列块可视模式后,我们按<code>$</code>键把选区扩大到每行的行尾。乍一看,人们也许觉得这会很难,因为每一行的长度都是不一样的。然而在这个场景中,Vim知道我们是想把选区扩大到所选中的这些</p><p>确定好选区后,用<code>A</code>命令就可以在每行的结尾添加内容(参见Vim对“”及“a”的约定)。此命令让我们进入插入模式,且使光标停留在顶行。处于插入模式期间,任何输入的内容只出现在顶行,然而一旦返回到普通模式,这些修改就会被扩散到其余选中的行上。</p><p><strong>Vim对“i”及“a”键的约定</strong></p><p>Vim对于从普通模式切换到插入模式的命令有几个约定,<code>i</code>命令和<code>a</code>命令都完成此切換,并分别把光标置于当前字符之前或之后,<code>I</code>命令和<code>A</code>命令的表现类似, 是它们分别把光标置于当前行的开头和结尾Vim对于从列块可视模式切换到插入模式的命令也遵从类似的约定。<code>I</code>命令和<code>A</code> 命令都完成此切,并分把光标置于选区的开头和结尾。那和命令呢,它们在可视模式里千什么? 在可视模式及操作符待决模式中,i和a键沿用一个不同的约定。它们会被当作一个文本对象的组成部分,我们将在技巧51中深入探讨文本对象。如果你在列块可视模式里选中了一块区域,并且很奇怪为什么按i键没进入插入模式,那么换用<code>I</code>键试</p><p><strong>Vim命令行模式中的特殊按键</strong></p><p>有些命令在插入模式和命令行模式中可以通用。<strong>例如,可以用<code>&lt;C-v&gt;</code>和<code>&lt;C-u&gt;</code>分别除至上个单词的开头及行首,也可以用<code>&lt;C-v&gt;</code>或<code>&lt;C-k</code>&gt;来插入键盘上找不到的字符,还可以用<code>&lt;C-r&gt;&#123;register&#125;</code>命令把任意寄存器的内容插入到命令行,</strong></p><p><strong>在Vim的命令行模式中,给命令加一个叹号前缀(参见:h:!)就可以调用外部程序</strong></p><h2 id="技巧二十七用缓冲区列表管理打开的文件"><a class="markdownIt-Anchor" href="#技巧二十七用缓冲区列表管理打开的文件"></a> 技巧二十七用缓冲区列表管理打开的文件</h2><blockquote><p>了解文件与缓冲区的区别</p></blockquote><p>就像其他任一文本编辑器一样,Vim允许读取、编辑文件,并保存修改。在工作过程中,我们通常会说“我们正在编辑一个文件”,但真实情况并不是这样,我们所编辑的只是文件在内存中的映像,也就是Vim术语中的“缓冲区”。<br>文件是存储在磁盘上的,而缓冲区则存在于内存中。<strong>当Vim打开个文件时,     该文件的内容被读入一个具有相同名字的缓冲区。刚开始,缓冲区的内容和文件的内容完全相同,但当我们对缓冲区做出修改时,二者的内容就会出现差别。</strong> **如果我们决定保留这些修改,就可以再把缓冲区的内容写回到文件里。绝大多数Vim命令都用来操作缓冲区,**不过也有一些命令针对文件进行操作,这当中包括: write、: update 及: Saveas命令。</p><p>创建分割窗口</p><p><strong>Vim在启动时只会打开单个窗口。用<code>&lt;C-w&gt;s</code>命令可以水平切分此窗口,使之成为两个高度相同的窗口</strong>:<strong>或者可以用<code>&lt;C-w&gt;v</code>命令对其进行垂直切分,这样会产生两个宽度相同的窗口。这两条命令可以重复任意多次,结果就会把工作区一次次地切分为更小的窗口,就像细胞分裂那样</strong></p><p>**每次执行完<C-w>s和<C-w>v命令后,新生成的两个窗口都会显示与原窗口相同的缓冲区。把同一缓冲区显示在不同窗口里会很有用,特别是在编辑长文件时。**举个例子,我们可以滚动其中一个窗口,使之显示缓冲区的一部分,这样,在修改第二个窗口中缓冲区的另外一部分时,就可以参考第一个窗口中的内容</C-w></C-w></p><p><img src="https://s2.loli.net/2021/12/04/kObrJShwocqfYBp.png" alt="image-20211204171514488" loading="lazy"></p><p>在窗口间切换</p><p><img src="https://s2.loli.net/2021/12/04/QLFxho69iNwB7Dj.png" alt="image-20211204171535305" loading="lazy"></p><p>关闭窗口</p><p><img src="https://s2.loli.net/2021/12/04/engoAP6DCWKvzpw.png" alt="image-20211204171548052" loading="lazy"></p><p>改窗口大小及重新排列窗口</p><p><img src="https://s2.loli.net/2021/12/04/2AUkCXhiZPFd5q6.png" alt="image-20211204171608171" loading="lazy"></p><h2 id="技巧二十八基于单词移动"><a class="markdownIt-Anchor" href="#技巧二十八基于单词移动"></a> 技巧二十八基于单词移动</h2><p><img src="https://s2.loli.net/2021/12/04/lyen7sIvpwWF1xT.png" alt="image-20211204171637662" loading="lazy"></p><h2 id="技巧二十九深人理解vim寄存器"><a class="markdownIt-Anchor" href="#技巧二十九深人理解vim寄存器"></a> 技巧二十九深人理解Vim寄存器</h2><p>引用一个寄存器</p><p>Vim的删除、复制与粘贴命令都会用到众多寄存器中的某一个。<strong>我们可以通过给命令加<code>&quot;&#123; register&#125;</code>前缀的方式指定要用的寄存器</strong>。<strong>若不指明,Vim将缺省使用无名寄存器</strong></p><p><strong>让我们看一些引用寄存器的例子,如果我们想把当前单词复制到寄存器a中,可执行<code>&quot;ayiw</code>,或者,可以用<code>&quot;bd</code>,把当前整行文本剪切至寄存器b中。在此之后, 我们既可以输入<code>&quot;ap</code>粘贴来自寄存器a的单词,也可使用&quot;<code>bp</code>命令粘贴来自寄存器b 的一整行文本,两者互不干扰。</strong></p><p>复制专用寄存器(&quot;0)</p><p>当我们使用<code>y&#123; motion&#125;</code>命令时,要复制的文本不仅会被拷贝到无名寄存器中,而且也被拷贝到了复制专用寄存器中,后者可用数字0(参见: h quote①)加以引用。</p><p><strong>复制专用寄存器,顾名思义,仅当使用<code>y &#123;motion&#125;</code>命令时才会被赋值</strong>。换句话讲, 使用、s、c{ motion}以及d{ motion}命令均不会覆盖该寄存器。如果我们复制了些文本,可以确信该文本会一直保存于寄存器0中,直到我们复制其他文本时才会被覆盖。复制专用寄存器是稳定的,而无名寄存器是易变的</p><p>V<strong>im提供了一组以26个英文字母(参见: h quote alpha@)命名的有名寄存器</strong>。这意味着我们可以剪切(&quot;ad notion))、复制(&quot;ay( motion)或者粘贴(&quot;ap)多达26段文本。</p><p>黑洞寄存器是个有去无回的地方,可用下划线(参见: h quote_)引用它。<strong>如果我们运行<code>&quot;_d motion&#125;</code>命令,Vim将删除该文本且不保存任何副本。当我们只想第10章复制与粘贴139 删除文本却不想覆系统剪贴板(&quot;+)与选择专用寄存器(&quot;*)盖无名寄存器中的内容时,此命令很管用。</strong></p><p>到目前为止,我们所讨论的寄存器都是Vim内部的。如果想从Vim复制文本到外部程序(反之亦然),则必须使用系统剪贴板</p><p><strong>Vim的加号寄存器与系统剪贴板等效,可用<code>“+</code>号(参见: h quote+①)引用。</strong></p><p><strong>如果我们在外部程序中用剪切或复制命令获取了文本,就可以通过<code>&quot;+p</code>命令(或在插入模式下用<code>&lt;C-r&gt;+</code>)将其粘贴到Vim内部。相反地,如果在Vim的复制或删除命令之前加入<code>&quot;</code>+,相应的文本将被捕获至系统剪贴板。这意味着我们能够轻松地把文本粘贴到其他应用程序中了。</strong></p><p>表达式寄存器(&quot;=)</p><p>Vim的寄存器通常被认为是保存一段文本的容器。然而,通过<code>“=</code>号(参见: h quote= ①)引用的表达式寄存器却是个例外。<strong>当我们从表达式寄存器获取内容时,Vim将跳到命令行模式,并显示提示符“=”。这时,我们可以输入一段Vim脚本表达式并按<CR>执行,如果返回的是字符串(或者可被强制转换成字符串的数据),Vim将会使用它。</CR></strong></p><h2 id="技巧三十宏的读取与执行"><a class="markdownIt-Anchor" href="#技巧三十宏的读取与执行"></a> 技巧三十宏的读取与执行</h2><blockquote><p>宏允许我们把一段修改序列录制下来,用于之后的回放</p></blockquote><blockquote><p>许多重复性的任务都会涉及多处修改。如果想要自动完成这些修改,我们可以录制一个宏,然后执行它。</p></blockquote><p><code>q</code>键既是“录制”按钮,也是“停止”按钮。为了录制我们的按键操作,一开始需要按<code>q&#123; register&#125;</code>,从而指定一个用于保存宏的寄存器。当状态栏中出现“记录中”时,表示录制已经开始。此后,我们执行的每一条命令都将被宏捕获,直到我们再次按下<code>q</code>键停下为止</p><p>首先,我们输入<code>qa</code>开始录制宏并将其内容保存至寄存器a中,然后,在第一行上做两处修改,在行尾添加一个分号,再在行首添加一个单词<code>var</code>。在完成这些修改后按<code>q</code>键停止宏的录制</p><p>我们可以通过以下命令査看寄存器a中的内容:</p><p><img src="https://s2.loli.net/2021/12/04/fiAuSEGVUyKgO7n.png" alt="image-20211204172115199" loading="lazy"></p><p>尽管这些内容难以理解,但对于你应该似曾相识,因为它们正是刚刚录制的命令序列唯一的不同可能是符号,它代表Esc键</p><p>通过执行宏来回放命令序列</p><p>我们可以用<code>@&#123;register&#125;</code>命令执行指定寄存器的内容(</p><p>也可以用来重复最近调用过的宏</p><p>Vim有一组丰富的动作命令集,通过它们,可以直达文本文件的各个角落。因此我们要善用这些命令千万别光为了让光标到达目标而一味地敲<code>l</code>键。请记住,Vim会机械地执行你的按键操作。例如,当你录制宏时,将光标向右移动了10个字符的位置,这一次目的是达到了,但回放宏时怎么办?因为在另一段上下文中,“将光标向右移动10个字符的位置”也许已经移过了,或是还没到。<br>面向单词的动作命令,如<code>w</code>、<code>b</code>、<code>e</code>和<code>ge</code>,与面向字符的动作命令h和相比,更具灵活性。<strong>如果我们录制“动作命令0,后跟e”,当每次执行该宏时,我们都能预料得到一致的结果,光标会移到当前行第一个词的最后一个字符上。只要该行包含至少一个词,无论该词包含多少个字符,都能够到达目标</strong>。<br>我推荐你用査找命令定位,或者用文本对象。总之,请用好Vim提供的所有动作命令,尽量使你的宏兼具灵活性与可重复性。还有一点别忘了,在录制宏的过程中,     禁止使用鼠标</p><p>当动作命令失败时,宏将中止执行</p><p><strong>如果宏执行动作命令失败了,Vim将中止执行宏的其余命令。这是一项功能,而不是漏洞。我们可以用动作命令进行简单测试,来判断该宏是否应该在当前上下文中继续执行</strong></p><p>考虑这样一个例子:我们要找一个模式(     pattern),假设文档中有10处匹配。<br>我们开始录制宏,先用n重复上一次的査找操作。一旦光标移到匹配处,我们会做些小的修改。然后,停止宏的录制。改完这处后,这个地方就再没有可匹配的模式了至此,整篇文档只剩9处匹配了。<br>当我们执行这个宏时,光标将移到下一处匹配并做相同的修改。至此,整篇文档只剩下8处匹配了。就这样,我们周而复始地执行该宏,直到再也没有一处匹配为止。<br>若此时再执行该宏,由于已没有匹配项,n命令会失败,宏将中止退出。</p><p>假设宏保存在寄存器a中。这一次,我们不再执行10次a,而是改用次数作为前缀执行宏100a。这种技术的过人之处,就在于执行宏的时候,可以不必顾忌执行的次数。真地不用去管执行次数了么?当然!我们可以执行100Ga,甚至是10000a,反正结果都是一样的。</p><h2 id="技巧三十一加次数回放宏"><a class="markdownIt-Anchor" href="#技巧三十一加次数回放宏"></a> 技巧三十一加次数回放宏</h2><p>于重复次数不多的工作,点范式是一种高效的编辑策略,但它不能指定执行的次数。为了克服该限制,我们在技巧3中,我们用点范式处理过这行文本:可以录制一个廉价的、一次性的宏,然后再加次数进行回放。</p><p>通过录制一个最简单的宏,我们可以模拟执行11次的;,即q;.q。首先,qq 将指示Vim录制后续的按键操作并将它们保存至寄存器q中。然后,我们再输入命令;。最后,我们按下键结束宏的录制。现在可以加上次数11执行这个宏11 即执行11次;</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路漫漫其修远兮</title>
      <link href="/2021/10/24/%E5%BC%80%E5%AD%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2021/10/24/%E5%BC%80%E5%AD%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>如愿来到学校，开始了<a href>按计划</a>的学习。</p><p>如今一个月过去，就在这里做一个小总结，顺便“展望”一下自己的未来吧。</p><h2 id="过去"><a class="markdownIt-Anchor" href="#过去"></a> 过去</h2><h3 id="伊始"><a class="markdownIt-Anchor" href="#伊始"></a> 伊始</h3><blockquote><p>今年的9.24，我立了个flag，规划了自己三个月的学习。</p><p>为了激励自己学习，我发了空间和朋友圈，并将其置顶在了博客里。承诺如果未完成，就自罚500，并抽个3个人每人100元奖励。</p></blockquote><p>可能你以为我一定会认真学习，争取早日取得成绩。</p><p>然而，并没有。</p><p>事实上，我在家摆烂了半个月。这半个月里，我几乎没有任何学习，整天无所事事。究其原因，应该是我在很早之前就给过自己心理暗示，认为在家学习十分低效，不想在家学习。这样想来，应该是每当我想认真学习的时候，这个暗示就会跑出来“动摇”我，让我无法集中精力，并最终放弃。而偏偏因为疫情，我不得不宅家半月，就有了那样的结局。</p><p>就这样，时间来到10.8日，这天，我如愿来到学校，在经历了两天的整理后，我终于开始了“蓄谋已久”的学习。也就是说，在10.10日的那个周一，到10.24的这个周末，我在学校一共学习了两个星期。</p><h3 id="总结问题"><a class="markdownIt-Anchor" href="#总结问题"></a> 总结(问题)</h3><blockquote><p>下面就对这两个星期的学习做一个总结和评价</p></blockquote><p><strong>先说结论，我的在校学习，高动力但低效率。</strong></p><p>首先是高动力，我在学校的学习是十分积极的，每天早上起来到教室的路上，我会拿着手机用软件去背单词。每天晚自习结束后，我也会去图书馆前去背新概念的课文。平时的一些空闲时间，我会学习自己规划好的内容，有时候还会放弃午休去自习室学习。从时间上来看，我每天“学习”的时间得有10个小时以上，这反映出了我学习的积极性。</p><p>然后就是低效率，我在这“高强度”的学习下到底学到了多少东西呢？</p><blockquote><p>这里有我统计的一组数据，在过去的两周里，我看到了<code>C++primer</code>的前六章（书的第240页，总进度240/760，没做练习和笔记），数据结构的前5章（书的104页，总进度104/232，没做练习和笔记），复习了2800左右的单词（以前都背过的），背了两篇很短的新概念课文（新概念2，总进度2/90）。读完了一本《影响力》。</p></blockquote><p>这个数据乍一看不是很低，但请注意，我看这些书是没有做笔记和课后练习的，仅仅只是在书上画了线而已。英语方面更是少之又少，2800个单词都是之前背过的，在看到的时候只需要过一遍即可，拢共花的时间不到三小时。至于两篇课文，新概念2的课文，大家懂的都懂，一篇课文100来个单词，句子短的离谱（不过我是为了学习语调，背的少也无所谓了）。</p><p>这些东西真的需要我每天花10多个小时，学了两个星期才学完吗？答案是不需要，自我感觉如果认真一点，可能学完这些东西1个星期都不需要。</p><blockquote><p>什么原因导致了低效的学习呢？</p></blockquote><p>在探究之前，我想讨论一下我的学习方法。</p><p>按照我之前flag里的构想，我的<code>C++primer</code>应该是英文版的，数据结构的学习应该是看MIT的网课。同时要结合ipad和电脑，做一份全面的笔记。但这些计划在来到学校后，就变得理想化了。首先是开学第二天，我的ipad就因为屏幕上出现了绿线拿去给京东去返修了，直到前天才换新到手。这让我没有<code>C++英文版</code>，因为没有ipad上的MN3，我无法适应做笔记的节奏。所以我选择了中文版的书，并只是在上面画线，没有做笔记。同样是没有ipad，少了大屏，看网课的舒适程度大大降低，加之学校同样开了数据结构的课，作业什么的都需要上交，所以我选择了看书学习数据结构。</p><p>这样一来，我整个flag计划就都被打乱，让我开始的几天有点难以适应。但是因为不得不改变计划，也让我在学习的时候认识到我之前flag计划里的缺点。</p><p>我发现我flag里的计划都太理想化了，首先就是语言，英文版的内容固然更周到有趣，但受限于我的语言功底，看懂这些需要消耗大量的时间，这对于要争分夺秒打基础的我是十分不值得的。但我这个计划都是以英语学习体系为基石的，换成中文，那就要放弃几乎整个计划。其次是笔记方面，原先的我很依赖ipad上的MN3，因为它的强大与方便。会在我做笔记时省下很长时间。这好像给了我一个错觉，让我认为可以靠它很方便的做出任何科目的最完整的笔记而耗时很少，这让我在记笔记方向上钻了牛角尖，老是想着怎么笔记做的完整，而忽略了实际上一些科目更注重实践，一些容易的且重复的内容没必要浪费时间。</p><p>然后是懒散的学习心态，这个问题其实在家的时候就出现了，之前的文章中也提到过：</p><blockquote><p>我不再像高中和初中时那般有耐心：对于一些困难的东西，我总会潜意识决定要放在明天做。比如今天我要看C++primer，本来的计划是看两个小时，但是看到一个半小时的时候遇到了一个难点，不是很好理解，加之已经看了一个半小时了，就会想着休息一下，这短暂的放松让我重新面对这些问题时更加觉得困难。于是心里想着等明天再看，这个明天再看的心理是来源于自己潜意识里认为明天没有今天学那么多的东西，精力更加充沛，思维会更加活跃，而事实上，明天的我也未必会比今天更高效，状况非常多，可能今天熬夜看剧，明天会更累，或者明天早上起来肚子不舒服，或者因为一些小事和父母或者同学生闷气，这些都会影响我学习的效率。而且要命的是这些小的感受和情绪在学习的过程中会被放的很大，以至于我会带着烦躁的情绪去学习，效率更低。不但完不成自己定下的目标，而且看着拉下的越来越多，就越来越提不起精神去学习。再次回到最开始的状态。</p></blockquote><p>在这几天的学习过程中，虽然我会尽力的克制，但这方面的问题还是很大的影响到了我的学习效率。虽然不会向之前那样遇到问题会直接放弃学习，但当影响大到一个程度后，我就会心不在焉，注意力会时不时的放到其他方面。这点在课堂上老师讲课（老师越活跃，我的效率就会越低）时和平时的学习中有其他事情发生时（这个“事情”有很多种，比如要写一篇文章，网上买的东西要到了，或者被别人安排了其他的任务等等）尤为明显。我觉得这方面的原因时我分不清事情的优先级，总是下意识的把一些低优先级的事情放到学习上面，但心理上还是觉得学习这件事的优先级更高，这样就会在这些事情上抉择，导致注意力下降，学习效率也不高。</p><p>最后是对自己实力的过高评估，我在接受困难的任务后会变得很兴奋，总认为自己可以接下挑战并在短时间内完成的很好，这种状态仔细思考后可能是从初中产生的，那时候的实力确实很强（升高中时我是全校第一进入的实力最好的高中），那时，我在接受到挑战后总是可以完成的很好。所以可能养成了骄傲自大的这种隐性的性格，但到大学之后，知识体系变得更加复杂，很多任务并不容易，但我同样以初中的思维去考虑它，这就导致了我在设立目标时候的理想化，总是给自己很少的时间去做一些复杂困难的任务，到最后却无法在自己规定的时间完成，打乱了学习计划。</p><h3 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决(办法)</h3><p>这样看来，我学习效率低的原因总结下来有以下几点：</p><ul><li>理想化的学习方案</li><li>对自己实力的过高评估</li><li>懒散的学习心态</li></ul><p>那么，针对这些问题，也应该去想一些办法。</p><p>我想到的解决方案是重新制定学习计划，这个可能会需要一段时间的考察，一会会留下一个蓝本，然后在此基础上进行一些修改。在我现在的构想中，这个计划应该符合自己的水平，同时照顾到自己的心态，最重要的是，最大可能的将一些外在因素考虑进去，做到及时的更新。</p><h2 id="未来"><a class="markdownIt-Anchor" href="#未来"></a> 未来</h2><p>总结完了现在，是时候思考一下自己的未来了。</p><p>事实上，我曾经做过很多对未来的规划，对未来做过很多种考虑，但很多都没有考虑实际情况，算是空想，说的再难听一点是像做白日梦，由于内容过于难以启齿，在这里就不多说了。</p><p>现在，我又要开始做规划了，虽然肯定会有不合理的地方，不过我还是挺喜欢那种畅想未来的时候那种沉浸其中的感觉。</p><p>这次规划分成两个部分，短期（大二）和长期（大三和大四）两个部分。</p><h3 id="短期规划"><a class="markdownIt-Anchor" href="#短期规划"></a> 短期规划</h3><p>我把短期时间分成下面几段：</p><ul><li><p>现在</p></li><li><p>flag结束（1.1号）</p></li><li><p>蓝桥杯开始（明年3月底）</p></li><li><p>大二结束</p></li></ul><ol><li><p>现在到flag结束</p><p>这段时间还是和上次flag的基本目标一致，但是计划会做很大的变化。目的是打好C++和数据结构的基础</p></li><li><p>flag结束到蓝桥杯开始</p></li></ol><p>这段同样是打基础的时间，这个时期应该是最紧张的，要把算法基础打好，同时还要刷题去提高应对比赛</p><ol start="3"><li>蓝桥杯结束到大二结束</li></ol><p>这个时期数据结构算法方面的基础就应该打好了，就要开始考虑一些其他的东西了，这个方面具体还没想好（前端？后端？）。</p><h3 id="长期计划"><a class="markdownIt-Anchor" href="#长期计划"></a> 长期计划</h3><p>长期规划最主要是教资和考研以及它们附带下来的一些考试（四六级）。</p><p>这部分就没有具体的计划了，只有大体的方向。简单说一下。</p><h4 id="四级六级"><a class="markdownIt-Anchor" href="#四级六级"></a> 四级|六级</h4><p>四级时间是明年的六月份，感觉不会有什么问题。六级应该是在大三考试（还不是很了解）</p><h4 id="教资"><a class="markdownIt-Anchor" href="#教资"></a> 教资</h4><p>教资算是大学里面第一场重要的考试了，这场考试一定要好好准备。说到当老师，我的感觉并不是十分强烈，可能骨子里还是有一种想要往前走的意志吧。不过还是要把教资当做自己的后路。考试时间是明年的10月底。</p><h4 id="考研"><a class="markdownIt-Anchor" href="#考研"></a> 考研</h4><p>如果说教资是后路，那么考研就是往前走的跳板，这个算是第二场重要的考试了，也要好好准备。这个我准备前面数据结构和算法的基础打好之后就开始着手规划了，我给自己定的目标是至少是个211。因为不想像高考一样留下那么大的遗憾。</p><h3 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h3><blockquote><p>不管是短期还是长期的规划，都是非常具有挑战性的，要做非常细致的规划，还要有巨大的勇气和毅力。总之，要开始卷起来了！</p></blockquote><h2 id="碎碎念"><a class="markdownIt-Anchor" href="#碎碎念"></a> 碎碎念</h2><p>要说的都说完了，感觉写的还是挺沉重的，诚然， 问题很明明显。但是找到问题就有解决的可能，所以未来的路还是很明朗的。我从来都没有怀疑过这条路的准确性。所以只需要坚定地走下去就行了。</p><p>其实我感兴趣的东西还是有很多，如在github上维护一个项目。自己写个小游戏等等。随着C++和数据结构的深入，这些东西都要提上日程了。</p><blockquote><p>总之，希望自己成为一个有趣的人！</p></blockquote><blockquote><p>Change and Challenge！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> flag </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构学习笔记</title>
      <link href="/2021/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>之前在flag里不想要用教材去学数据结构，本来打算是去看MIT的网课，但是发现这样并不能逃掉学校里的数据结构课程，而且看了严奶奶的数据结构教材，确实十分对我的胃口，所以现在“真香”了。</p><p>虽然使用的是大学的教材，但听课跟我还是占不着边，我依然是自学为主。严奶奶的这本教材十分严谨简洁，但因为使用的是介于C和C++的类C语言，而且从来不写代码前面的一些声明，所以读起来算是有点晦涩的。</p><p>我在做笔记时，会把前面的代码声明补充进去，而且将其中的数据结构和算法以C++实现。并附上自己的理解。</p><p>因为是自学，所以速度必须要快。所以不会对书中的习题作答。这本书算是打基础，后面还有《数据结构和算法分析》和《算法》，以后也会做笔记的。</p><h2 id="读前须知"><a class="markdownIt-Anchor" href="#读前须知"></a> 读前须知</h2><h3 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h3><blockquote><p>拿第二章第一节的线性表的的顺序存储来举例，假设我们要创建一个顺序表的数据结构，按照传统的写法，我们可能会这样写。</p></blockquote><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#define OK  1#define ERROR  0#define OVERFLOW -2 typedef int  Status;          &#x2F;&#x2F;通过typedef 类型别名来给int这一个整型命名为Status#define MAXSIZE 100          &#x2F;&#x2F;顺序表可能的达到的最大长度&#x2F;&#x2F;顺序表的创建typedef  struct&#123;             &#x2F;&#x2F;struct是结构体语句，用来创建数据结构，typedef类型别名将这个数据结构命名为SqList    int *elem;               &#x2F;&#x2F;存储空间的基地址，是一个数组指针（elem是一个指针，指向的是一个数组）    int length;             &#x2F;&#x2F;length表示表长    return OK;&#125;SqList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，代码的第8-12行创建了一个顺序表，命名为SqList。顺序表内部有一个指针数组用来存放基地址，有一个length整型表示表长。</p><p>这样写当然没有什么问题，但这仅仅表示的是创建顺序表这一个操作，为了这一个操作，我们需要写前面的声明，需要定义宏常量，必要的时候还要写类型别明。</p><p>接下来我们还会对顺序表进行初始化、插入、删除等一系列操作，这一系列操作都会建立在顺序表已经创建的情况下。我们的目的是记笔记，要的是高高可读性，这就需要我们的代码简洁和高效。</p><p>如果每一种操作都要附上一大堆的声明和前面的一些操作，这显然不符合我们的要求。但是如果都不写，又势必会影响到笔记的连贯性。</p><blockquote><p>那么就没有解决办法了吗？</p></blockquote><p>答案是：有，可以使用头文件解决问题。关于头文件，可以看这个：<a href="https://www.runoob.com/w3cnote/cpp-header.html%E3%80%82">https://www.runoob.com/w3cnote/cpp-header.html。</a></p><p>简单来说：我们只需要在一个源文件中写操作，然后把它引入到头文件中，再把头文件引入到整体的程序中去即可，这样就没必要去做多次的声明，而且可以让程序要更好的封装性。减小了使用的难度和错误率。</p><p>为此，在每一个数据结构中，我们都有三个文件，还是以顺序表举例，我们有：存放操作的源文件——SqList.c，头文件——SqList.h。主体文件——SqList-main.c   。</p><p>按照这种形式，在写算法实现代码时，我会在开始将代码的主体框架写出来，在遇到每一个操作时，我会指出这些代码将要写在哪里，起了什么作用。最后，我会给出整体的代码文件，大家可以靠着这个来系统的查看。</p><h3 id="事例说明"><a class="markdownIt-Anchor" href="#事例说明"></a> 事例说明</h3><p>书中的算法仅展示了分析部分，并无事例演示，所以我会尽量的找一些代表性的例子去实践这些数据结构，并将代码和解析附在文末。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《人间失格》</title>
      <link href="/2021/09/27/%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC/"/>
      <url>/2021/09/27/%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="21-9-27"><a class="markdownIt-Anchor" href="#21-9-27"></a> 21-9-27</h2><p>书看完了，十分压抑的感觉。</p><p>或许从未经历过绝望，或许没有那么深的阅历。</p><p>但作为一个心思敏感的人，读书时也设想过如果在相同的处境，我自己的做法或许并不那么极端，但与主人公仍然会有很多相似之处。</p><p>这本书我会重读很多遍，希望可以读出更多不一样的东西。</p><p>文笔十分不错，溢出书本的孤独、压抑、挣扎中带着乐观与期望。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《杀死一只知更鸟》</title>
      <link href="/2021/09/22/%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F/"/>
      <url>/2021/09/22/%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F/</url>
      
        <content type="html"><![CDATA[<img src="https://i.loli.net/2021/09/22/uYyOjeoFzUNk7QI.jpg" loading="lazy"><span id="more"></span><h2 id="作者简介-豆瓣"><a class="markdownIt-Anchor" href="#作者简介-豆瓣"></a> 作者简介     @豆瓣</h2><blockquote><p>哈珀•李（1926— ）</p></blockquote><blockquote><p>生于美国阿拉巴马州， 曾被授予普利策小说奖及其他众多文学奖项。她与杜鲁门•卡坡蒂是幼年的邻居和一生的朋友。《杀死一只知更鸟》据说是以卡坡蒂为原型之一创作的，现已成为公认的美国文学经典。此后，她一直隐居在家乡亚拉巴马的小镇上 ，拒绝各种采访，过着平静的生活。有人问她为什么不在盛名之下接着写作，她回答：“有过这样一次，还有什么可写的？”</p></blockquote><h2 id="内容简介-豆瓣"><a class="markdownIt-Anchor" href="#内容简介-豆瓣"></a> 内容简介   @豆瓣</h2><blockquote><p>成长总是个让人烦恼的命题。成长有时会很缓慢，如小溪般唱着叮咚的歌曲趟过，有时却如此突如其来，如暴雨般劈头盖脸……三个孩子因为小镇上的几桩冤案经历了猝不及防的成长——痛苦与迷惑，悲伤与愤怒，也有温情与感动。这是爱与真知的成长经典。</p></blockquote><h2 id="读书笔记"><a class="markdownIt-Anchor" href="#读书笔记"></a> 读书笔记</h2><p>读此书时还没有要写读书笔记的概念，所以我挑了一篇不错的书评来看，这个书评来自微信读书，作者是@<strong>哆啦蒙太奇</strong></p><blockquote><p><strong>这份悲观，点缀着说好的勇敢</strong></p><p>《杀死一只知更鸟》是一本关于勇气和成长的书，它对勇敢的定义是：“在你还没开始的时候就知道自己注定会输，但依然义无反顾地去做，并且不管发生什么都坚持到底。”<br>很显然，这不是每个人都能做到或情愿去做的，也正因如此，这份勇敢才显得弥足珍贵。《杀死一只知更鸟》中的阿迪克斯就是一位勇士，在“大萧条”时期的美国南部，他明知替黑种人打官司几乎毫无胜算，甚至还可能搭上孩子们的安全和自己的声誉，但他还是选择挺身而出。全书用上几乎所有的篇幅诠释了这种追求真理永不言败的英雄观，满满正能量使得该书成为美国中小学必读书目、图书馆借阅次数最高的图书，并在一次民意调查中力压《圣经》，获得“最具启示意义的书”称号。<br>但是，或许因为我已经错过了阅读这本书的最佳时机——青少年时期，我从中联想到现实中一些令人悲观的现象，而这些造成悲观情绪的因素正源于书中那些本该触动人心、催人向善的故事设定。<br>完美的人设有赖独特的视角<br>“阿迪克斯是一位完美的父亲、完美的公民、完美的绅士。”我想大多数读过这本书的人都会对阿迪克斯做出这样的评价。的确，他性格温柔善良却在关键时刻勇敢无畏，他有体面的身份却致力于帮助底层黑人维护权利，他身负惊人绝技却从不卖弄、更不滥用，即使在最波澜不惊的日常生活中，他也显得风度翩翩、温文尔雅，对孩子体贴入微、对邻居充满善意。电影版《杀死一只知更鸟》还找来主演《罗马假日》的大帅哥格里高利·派克来饰演阿迪克斯（派克因此片获得奥斯卡最佳男主角），以至于很多读者高声宣布“也想要这样的爸爸”或者“想嫁给阿迪克斯”。<br>现实中有这样完美的人吗？我认为没有。<br>之所以得出这样的结论，并不是因为我的嫉妒心在作祟。在有了更多生活阅历和阅读积累之后我发现，很多人眼中如同“圣人”一般的人物其实也都存在各种各样的缺点：或许他非常博学，但他也盛气凌人；或许他将毕生献给伟大的事业，但他也追求声色犬马；他在外面人缘极佳，对家人却尖酸刻薄……不一而足。<br>虽然艺术形象历来是高于生活的，但当这个形象完美到超凡脱俗的时候，他所做的事就没那么可信了，至少打动人心的力量会打一些折扣。<br>好在完美的阿迪克斯不是客观意义的阿迪克斯，他只是斯库特和杰姆眼中的阿迪克斯，他的所作所为，是有经过两个孩子天真无邪的目光过滤的。成年人看来大大小小的毛病，在斯库特和杰姆这里根本意识不到。这正如父母如果是个优秀的人，ta在孩子眼里就一定是个完美的人。即使ta有时候固执己见、不干家务、啰里啰嗦、毫无浪漫感、对现状不满，但这些对于孩子来讲又算得了什么呢？<br>以孩子的视角来讲述这个摒除偏见的故事，正是这本书的一大特色。故事的前半段着重描写了几个孩子的日常生活和他们独具特色的游戏，后半段主线才逐渐趋于明朗。而他们的童年阴影“怪人拉德利”则作为一个隐藏支线贯穿全程，从打小对“怪人”根深蒂固的偏见到经历过成长后对“怪人”报以善意，孩子独特的视角不仅讲通了“阿迪克斯为何完美”，还给予读者一种从无到有、云开雾散的豁然感。<br>有意的歧视源于无意的偏见<br>书中关于白种人对黑种人的歧视发人深思，这种歧视从黑奴贸易时期到故事的发生时间“大萧条”时期，足以发展到在所有人心中根深蒂固的程度，即使有关于解放黑奴、人人平等的法律也难以例外。<br>现在，经过一代又一代的努力（当然这本书也起到了一定的助推作用），黑种人的地位得到极大提升。尽管仍有不少人（不止白种人）从内心厌恶黑人，但绝不可否认如今黑种人的生活状态不再是书中所描写的那般凄惨景象了。<br>但歧视链是不是就此根除了？绝没有，各种歧视仍然无处不在。不仅一些白种人还在歧视黑种人，事实上，一些黑种人甚至还会歧视白种人；又或者一些黑种人歧视黄种人的事也时有耳闻。<br>而更令人细思极恐的地方在于，这些有意识的歧视均脱胎于无意识的偏见。<br>何谓“无意识的偏见”？举个例子，在经典电影《十二怒汉》中有这么一个桥段：十二名陪审团成员在讨论一个来自贫民窟的黑人孩子是否是杀死他白人养父的真凶。其中多数人认为这没什么可讨论的价值，嫌疑人是黑人，还来自贫民窟，没有受过良好教育，品性顽劣，这些因素导致他们坚信凶手绝非他人。但他们绝不会承认（或从内心真的不认为）自己是个存在偏见的人，因此他们的偏见看似是“无意识”的，或说是潜意识的。<br>值得深思的是，不是只有西方人才有这种“无意识偏见”。国内后来翻拍自《十二怒汉》的《十二公民》中，这个桥段改为：十二名学生家长模拟陪审团，讨论一个关于被收养的富二代杀害养父的案件。由于这个孩子的生父是来自河南的务工人员，所以一些家长认为案情已经十分明朗，“养尊处优的富二代”和“河南务工人员”就很能说明问题了，他毫不感恩、他骄奢淫逸、他素质低下、他劣根难除，统统可以让此案盖棺定论。<br>顺带一提，我就是河南人。<br>“无意识的偏见”是“有意识的歧视”前奏，虽然很遗憾，但这种来自潜意识的偏见广泛存在于我们每个人的心中——“他家穷，所以他素质肯定不高”“他脾气大，对父母肯定不孝顺”“他喜欢跟异性说说笑笑，肯定对另一半不忠”等等。而《杀死一只知更鸟》借用“怪人拉德利”一家的故事告诉我们：这些都是需要我们有意识去杜绝的“无意识偏见”。<br>误伤知更鸟以及谁是知更鸟<br>这本书如果按照字面意思来翻译，其实应该叫做《杀死一只反舌鸟》，但译者“擅自”改为知更鸟我认为是绝对的明智之举。<br>知更鸟是一种小型鸣禽，性格温顺驯良，经常会毫无防备地飞到人身边寻找食物，被视为最亲近人类的动物之一而备受欢迎。知更鸟是为数不多维系大自然与人类的情感纽带，是人与自然交流互动的桥梁。所以，杀死知更鸟这种行为，意味着破坏和践踏这份宝贵的信任。<br>在书中，黑人小伙汤姆·鲁宾逊就是一只与世无争的“知更鸟”，但他的满腔善意并没能换来和谐友爱，最终被偏见和歧视组成的利剑杀死。<br>看起来，这似乎跟我们自身没什么关系，我们不可能做出这样伤天害理以怨报德的事情来。其实倒不一定。尽管我们可能没有“杀死”过任何一只“知更鸟”，但我们必定误伤或刻意伤害过。<br>我们再来讲讲上面的例子。我是河南人，当我意识到很多人对河南人存有偏见，我不可避免的在和外省的朋友接触时潜意识中会隐存自卑感和负罪感。“我被人瞧不起”和“我某位老乡曾做过让人瞧不起的事”，这块石头始终压在我的心底。尽管我没做过自认为出格的事，我的生活也谈不上受到多大影响，但谁也无法否认这根是永远无法拔除的。<br>“男人都是大猪蹄子，只会用下半身思考，永远只爱18岁小姑娘。”<br>“女人找对象只认钱，只要有钱，比她爸大的男人都愿意嫁。”<br>“护士每天照顾病人很累，回到家比谁都懒，千万别娶护士。”<br>“工人每天跟机器接触，会懂浪漫吗？会有情调吗？千万别嫁工人。”<br>“你985毕业的，怎么会来干这行啊？想什么呢？”<br>“他身上有病，说不定平时都不怎么检点的。”<br>······<br>这样的误伤，你承受过吗？这样的误伤，你做出过吗？<br>或许，我们只想做一只和他人亲近的知更鸟，别无他意。但我们会被误伤，我们也会在不自觉间误伤别人。“怪人拉德利”不就是吗？斯库特和杰姆明明是好孩子，为什么他们会认准拉德利是可怕的怪胎呢？<br>我们只能归结于与生俱来的天性。<br>结语<br>阿迪克斯只是一个有良知的普通人，他并不完美，我们也不可能完美。<br>无意识的偏见人人都有，如果不加抑制，将会升级为有意识的歧视。<br>我们都曾因偏见误伤过“知更鸟”，我们自身也都做过“知更鸟”。<br>人类，古往今来从没有逃脱过这些定律。<br>这些悲观的结论，我们应该如何去面对？《杀死一只知更鸟》告诉我们：你明知自己会输，但仍然义无反顾的去做，并且无论发生什么都会坚持到底。这就是勇敢。<br>我愿做一名勇敢的人，这些悲观，只是这份勇敢的点缀。偏见和歧视或许永远不会被彻底根除，但我选择相信，人类会不断成长，越来越多的人会选择勇敢的去成长。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>立一个flag</title>
      <link href="/2021/09/20/%E5%BC%80%E5%AD%A6flag/"/>
      <url>/2021/09/20/%E5%BC%80%E5%AD%A6flag/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><blockquote><p>上一篇<a href="https://liuhd.com/2021/09/14/%E5%85%B3%E4%BA%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/">关于未来的思考（碎碎念）</a>，总结了不少的问题，也尝试提出过一些解决办法。但据我开始写上一篇，已经过去整整一周了。这一周的时间里，我给自己找了各种各样的理由，将这些我本来应该立即执行的任务搪塞了过去。（<s>有一说一，宅在家里真的挺爽</s>），但这样下去我依然是个废物，没有任何改变。正好今天看b站时在热榜上看到了一个克服社恐的视频——<a href="https://www.bilibili.com/video/BV1mh411p79S?from=search&amp;seid=16274933938089722126&amp;spm_id_from=333.337.0.0">3句话，让你从社交恐惧→社交牛逼 | 奸商套路分享</a>。对里面<strong>通过立flag来提高面对社恐的执行力</strong>十分认同。正好我既废物又有社恐。于是就趁着这个发热冲动期立下一个未来学习的flag。并把它置顶，激励我的学习。也<strong>欢迎大家打脸</strong>。</p></blockquote><img src="https://i.loli.net/2021/09/22/NQDbCqOYPeWhkB7.jpg" loading="lazy"><span id="more"></span><h2 id="具体flag"><a class="markdownIt-Anchor" href="#具体flag"></a> 具体flag</h2><blockquote><p>首先，我是一个CS（计算机科学）专业的学生，（<s>虽然大一混过去了</s>），所以以下的学习基本围绕这一专业来开展。而关于学习路线的规划，是我在国内外各个社区，通过大牛的经验总结出来的（最后放上参考链接和图片），所以科学性是会有一些保证的。</p></blockquote><p>目前要做的主要事情只有两个：C++和数据结构</p><p>下面开始具体的目标，执行方法（通过表格形式列出）</p><table><thead><tr><th>科目</th><th>方法</th><th>目标</th><th>时间</th></tr></thead><tbody><tr><td>C++</td><td>看书：《C++primer》（英文原版）</td><td>看完书的前十二章，并做好笔记，最重要的是建成知识库</td><td>三个月（9.27-1.1（元旦））</td></tr><tr><td>数据结构</td><td>网课（MIT6.006算法导论）</td><td>看完网课，完成作业和测试</td><td>三个月（9.27-1.31（元旦））</td></tr><tr><td>看书</td><td><a href="https://liuhd.com/2021/09/13/%E5%BF%83%E7%90%86%E5%AD%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AF%BC%E8%AF%BB/">读自己感兴趣的书</a></td><td>将<a href="https://liuhd.com/2021/09/13/%E5%BF%83%E7%90%86%E5%AD%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AF%BC%E8%AF%BB/">列表</a>在内的书看完，并做好读书笔记</td><td>三个月（9.27-1.31（元旦））</td></tr></tbody></table><h2 id="学习细节"><a class="markdownIt-Anchor" href="#学习细节"></a> 学习细节</h2><h3 id="资料介绍"><a class="markdownIt-Anchor" href="#资料介绍"></a> 资料介绍</h3><blockquote><p>上面的学习内容基本上通过i电子设备实现，我的设备是2020款的iPad Pro、一台联想笔记本和一部华为手机。</p></blockquote><ul><li><p>C++primer（英文版）</p><p>共1399页，（照片放在最下面），前十二章共614页。我会把不认识的英语单词做成卡片，就像下面的图片那样。让后通过iPad，电脑，手机间各种软件的结合完成一个知识库集成到OneNote上。最后学习成果的检验也会放在这里。把这本书的习题认认真真的完成一遍。</p></li><li><p>数据结构</p><p>这个是个很大的科目，MIT并没有专门的数据结构课程，大量的数据结构的知识都包含在算法课程里面，前面提到的6.006算法导论就是最入门的一门课程，共有24课，视频在YouTube上，作业共有7课。</p></li></ul><h3 id="资料展示"><a class="markdownIt-Anchor" href="#资料展示"></a> 资料展示</h3><blockquote><p>这个部分是我资料的图片介绍</p></blockquote><p>C++primer：</p><p><img src="https://i.loli.net/2021/09/21/VKZdlxcrpAYmzbD.png" alt="Audits - Lighthouse" loading="lazy"><em>英文版封面（上面有页数)</em></p><p><img src="https://i.loli.net/2021/09/21/f9KjAeSN2lxFo8v.png" alt="Audits - Lighthouse" loading="lazy"><em>第十二章结束</em></p><p><img src="https://i.loli.net/2021/09/21/sDM8WhqIgx6QcKa.png" alt="Audits - Lighthouse" loading="lazy"><em>MIT课程讲义</em></p><h2 id="方法指导资料"><a class="markdownIt-Anchor" href="#方法指导资料"></a> 方法指导资料</h2><p><strong>这个部分主要介绍学习路线和学习方法，其实也是我探索的过程。内容很长，就当是唠嗑，不喜欢的可以直接跳过。</strong></p><blockquote><p>知乎有个问题叫<a href="https://www.zhihu.com/question/356351510">你的编程能力从什么时候开始突飞猛进？</a>，这个问题引发了程序员之间的广泛讨论，截止到现在，这个问题在知乎的浏览量已经超过了千万。</p></blockquote><p><img src="https://i.loli.net/2021/09/21/bHFTOq7MLnPI2Cx.png" alt="Audits - Lighthouse" loading="lazy"><em>你的编程能力从什么时候开始突飞猛进？</em></p><p>这里面有很多大佬分享了自己的经历经验。</p><p><img src="https://i.loli.net/2021/09/21/Rv2DlpAnw71gsTx.png" alt="Audits - Lighthouse" loading="lazy"><em>这个答主分析的鞭辟入里，拿出来让大家看看</em></p><p>相关的回答还有很多，大家没事可以去看看，学学别人的经验，应该对自己会有提升。</p><blockquote><p><strong>这里面一位答主<a href="https://www.zhihu.com/people/jie-bei-51">MutexLock</a>，一名华科的毕业生，目前在腾讯任职，分享了自己大学时间的学习经历，干货非常多，把自己大一到找工作之间学习过程写的十分详细。</strong></p></blockquote><p><img src="https://i.loli.net/2021/09/21/Z3hc4OKzQfdYvxr.png" alt="Audits - Lighthouse" loading="lazy"><em>里面写了学习的规划和实施</em></p><blockquote><p><strong>除此之外，答主还写了一篇完整的学习路线，内容同样的十分详细。</strong></p></blockquote><p><img src="https://i.loli.net/2021/09/21/Svh2GqAnKi5DPYN.png" alt="Audits - Lighthouse" loading="lazy"><em>学习方向，学习路线，学习方法都包含在了这篇里面</em></p><p>上面说是适合后端工程师，但我的感觉是<strong>适合所有CS（计算机科学）的学生</strong>，本身计算机科学涉猎广泛，可以说上面提到的所有内容计算机科学专业的同学都能接触到，但是广泛中也有要学好的基础，对于任何计算机专业的学生来说，编程，算法，这些都是最重要的。所以编程语言，数据结构，算法分析。这三门课也是一定要掌握好的。因此，相对于学校的那种广撒网的教育方式，我认为<strong>花更多的时间打磨这些才是重中之重，毕竟普通学校的绩点评分可打不过Github上的Star数目。判断一个人有才的标准不是成绩而是能力</strong>（仅限于普通学校，985，211那种没话说）。所以根据这个标准我做了上面的学习计划。</p><p>首先是编程语言的选择，这个可以说是很有争议的地方了，每年在各个论坛上都有人在争论那个语言好，那个占有率高，那个用起来最舒服。我个人认为语言没有好坏，现在的主流语言都有自己独特的使用场景，有些小众的语言在特定的方面也是无可替代的。但作为专业的学生，<strong>我认为先选择一门语言去系统学习，了解编程的思维，方法</strong>比对其他语言评头论足有益的多。</p><p>我的选择是<code>C++</code>，很多人觉得选择<code>C++</code>是十分不智的，这是一门十分“古老”的语言，分支十分多，用法混乱且复杂，最重要的是他十分难学。程序员间有个段子——没人敢在简历上写精通<code>C++</code>。但是这些缺点也是我选择C++的理由，我希望能在学完后掌握一定的抽象的思维，并将其运用到其他方面。而且我内心算是一个想要挑战自己的人，说白了就是想成功然后装逼。各种因素混合在一块，让我决定把入门的语言定成了<code>C++</code>（还是有一定的C的基础）</p><p>关于C++的学习方案，网上有很多的内容，我个人不喜欢这种重要的计算机科目通过网课学习，因为我觉得被动的学习效率很低，所以我更加倾向于<strong>主动的看书</strong>。这一点和上面大佬的学习方法很像，我也十分认同大佬的学习方法。</p><p><img src="https://i.loli.net/2021/09/21/GuQ4gq2k8JtRAbi.png" alt="Audits - Lighthouse" loading="lazy"><em>大佬的方法</em></p><p>所以我对<code>C++</code>的学习主要的方式就是看书，我选择的入门资料是英文版的<code>C++primer</code>，原因是电子版的英文版配合iPad强大功能，可以把单词方面的困难解决掉，同时英文原版也可以精进我的计算机英文，在以后看英文文章和在社区提问问题也十分方便。而看书的主要方式是在iPad上用marginnote3做笔记。笔记是我内化知识的一个很重要的部分，通过笔记将知识点记录下来，然后反复的查看，常看常新，直至把知识完全消化。而笔记之外，我打算用OneNote来实现笔记的整合，OneNote好处也很多，具体可以看我的这篇文章——，我设想的整合的结果是一个完整的资料库，当我要查看某个知识点时，可以快速的检索并找到相关的笔记，搜集的资料，以及与之相关其他知识的链接，这将是我学习计划里耗费最大的项目，也将是3个月后检测我成果的标准。</p><p>在学校C++的同时，数据结构不能落下，原因是他同样十分重要（<s>我不会告诉你是因为大一太混，大二没时间了所以只好含泪一起抓</s>），而同样的方法，再去看书的话时间上会十分紧张，而我准备的资料据说翻译贼烂，还找不到英文原版，所以这点我打算通过网课，也就是MIT来实现数据结构的学习。</p><blockquote><p>首先介绍一下什么是MIT，MIT就是麻省理工学院的缩写，这所大学有多强大家懂的都懂。MIT有一个公开课课程的网站，里面包含大量的MIT公开课，里面所有的资源均以免费的方式分享给世界上各地的人。这些公开课是经过老师的同意后放上的。质量十分高。知乎上有一篇介绍文章——<a href="https://zhuanlan.zhihu.com/p/112763953">替你总结一份MIT计算机课程</a>，放给大家看看。</p></blockquote><p><img src="https://i.loli.net/2021/09/21/LjthXop1O7T8D9v.png" alt="Audits - Lighthouse" loading="lazy"><em>MIT课程总结</em></p><p><img src="https://i.loli.net/2021/09/21/hbtrBPKxgjpwUdZ.png" alt="Audits - Lighthouse" loading="lazy"><em>MIT open courseware网站首页</em></p><p><img src="https://i.loli.net/2021/09/21/5dyTNjJmpL8kwvV.png" alt="Audits - Lighthouse" loading="lazy"><em>计算机科学学科列表</em></p><p>放给大家看看。</p><p>因为MIT没有专门的数据结构的课程，这个问题在刚才的知乎下也有人提出过。</p><p><img src="https://i.loli.net/2021/09/21/CPe4rhIWvwVBgLs.png" alt="Audits - Lighthouse" loading="lazy"><em>问题</em></p><p>答案也有人回答了，所以我选择的是6.006算法导论，相关资料在前面总结的有，这里就不多提了。总的来说，我打算按上面学习算法的方式学习数据结构，加上我买的两本书辅助的学习。当然，如果有可能，我打算在学完<code>C++</code>的基础后再开始数据结构的学习。这样更方便，但代价是时间把握上更加困难。</p><p>PS：说了这么多，提一些tip，这些都是我踩过的坑。</p><ol><li><p>不要沉迷知乎！</p></li><li><p>程序员不推荐使用百度</p></li><li><p>学会科学上网</p></li></ol><h2 id="失败的处罚措施"><a class="markdownIt-Anchor" href="#失败的处罚措施"></a> 失败的处罚措施</h2><blockquote><p>写了那么多，终于要到最正经的了。</p></blockquote><blockquote><p>没有处罚，那flag注定是摆设，所以要来点让人肉疼的。那么，开始吧！</p></blockquote><p>我决定：如果在我规定的时间内没有完成任务（C++  和数据结构的OneNote知识库），<strong>那么我会将自己每个月的生活费减少500（直到任务完成为止）并在评论区抽3个小伙伴没人100元</strong>（评论区留下联系方式，考虑到博客那贫瘠的浏览量，如果没人留的话就捐出去），届时我会把OneNote上传到云端，大家可以监督。</p>]]></content>
      
      
      <categories>
          
          <category> flag </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于未来的思考（碎碎念）</title>
      <link href="/2021/09/14/%E5%85%B3%E4%BA%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/2021/09/14/%E5%85%B3%E4%BA%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>转眼已经大二，网课也上了一周了。如果用一个字来形容我现在的状态，就是“迷”。</p><p>总结来说，就是每天不知道自己在干什么，完全凭着喜好做事。</p><p>一天，b站刷到了神仙up主的ae合成，觉得自己要立马行动起来，于是打开ae，在1小时后崩溃离开。别人抱怨网盘速度馒，不安全，于是又想搭建nsa，发现价格太高直接劝退。看到别人搞黑苹果，就想自己搞一个，结果花了几个小时看视频才发现自己的电脑不符合条件。又想着装台式机可以，于是又花时间了解装机知识。</p><p>这样做确实是由着自己的性子来的，兴趣足。所以做起来虽然花费时间很多。但并不感觉到累。做这些的感受就跟暑假搭博客和学ae一样，虽然一直都比较累，但成功后的成就感是确确实实的，而且确实学到了东西。虽然学到的基本上是皮毛，作为兴趣确实也学到了东西。比一直打游戏强一点。但这些都只是兴趣，应该是自己没事的时候玩玩。因为还有更重要的专业课。所以问题就变成了，我是要学好专业课还是随着自己的兴趣来？</p><span id="more"></span><p>对大多数人来说，专业基本上是以后的饭碗，不学好，饭都没的吃，还谈什么兴趣。</p><p>我的想法却是——是不是可以一起抓？于是:</p><p>看了公众号文章，觉得听力一定要提高，就对着新闻刷了四五个小时。</p><p>看到空间同学大佬又设计出了这样那样的代码，晒自己的学习成果，觉得再不学cs就跟不上别人的步伐。于是抱着C++primer啃了几天。</p><p>显然，我高估了自己的能力。</p><p>专业课对我来说无疑是枯燥无味的，大部头的书看起来十分无趣，而且又臭又长。加之在家上网课，还有很多任务要去做，而且在家的学习效率也确实不高，所以就有出现了那种兴趣使然的现象。然后陷入焦虑怪圈。</p><p>这样下去肯定不行的，所以我决定做出一些改变。在此之前先找出自己的优势和劣势。</p><p>优势</p><ul><li>其实我是可以看得下去那些大部头的，因为我发现C++primer英文版配上ipad强大的软件支持，居然可以看的比较有趣。这个有趣是建立在本身计算机英语不是特别困难，最重要的是ipad ，手机，电脑三者可以靠MN3和anki连接成一个学习闭环，我对这件事很有兴趣，但是也就是局限于有兴趣而已，不会像前面说的那么孜孜不倦的学习，反而会被偶然接触到的东西吸引，然后荒废学业的现象。</li><li>我有强大的搜索支持：我并不缺少学习的资源。网课。书，适合现阶段学习的电脑，ipad，各种学习工具。我的资源很多，设备也很给力。完全适合我大学的学习。</li></ul><p>劣势</p><ul><li>我不再像高中和初中时那般有耐心：对于一些困难的东西，我总会潜意识决定要放在明天做。比如今天我要看C++primer，本来的计划是看两个小时，但是看到一个半小时的时候遇到了一个难点，不是很好理解，加之已经看了一个半小时了，就会想着休息一下，这短暂的放松让我重新面对这些问题时更加觉得困难。于是心里想着等明天再看，这个明天再看的心理是来源于自己潜意识里认为明天没有今天学那么多的东西，精力更加充沛，思维会更加活跃，而事实上，明天的我也未必会比今天更高效，状况非常多，可能今天熬夜看剧，明天会更累，或者明天早上起来肚子不舒服，或者因为一些小事和父母或者同学生闷气，这些都会影响我学习的效率。而且要命的是这些小的感受和情绪在学习的过程中会被放的很大，以至于我会带着烦躁的情绪去学习，效率更低。不但完不成自己定下的目标，而且看着拉下的越来越多，就越来越提不起精神去学习。再次回到最开始的状态。</li><li>我的生活习惯十分不规律，主要是指作息时间。我知道好的作息会更加高效的工作。但一天的压力要在晚上释放，我不会打游戏，所以压力的释放方式大多是看看视频，看看剧，但感觉这些东西似乎并不能给我带来短期内更大的刺激，于是我会在这上面花很长时间，晚上看油管，刷b站能占用我生活的大部分。加上学校的打卡政策，像是给了我一个熬夜的理由，现在，凌晨打卡已经成为常态。随之而来的是早八课起不来，头昏，精神无法集中的现象。而想要改变是困难的，想要早睡会睡不着，而且本身这种坏习惯已经成型，即使一天好了，还会反复的来。</li><li>我不太善于与别人沟通，从童年开始，我就是一个怕生的人，害怕与别人交流，除了特别要好的朋友，我和别人几乎没有任何交流，这个交流断的很彻底，我在高中时期几乎没碰过qq，记得高一玩的要好的朋友，甚至到现在连联系方式都没有，高二分班后就没有再联系，现在估计都形同陌路了。有的朋友，学校里交流很多，一起嬉戏玩闹，分开后虽有联系方式，但脱离了班级的载体，我根本不知道要和他们聊些什么，以至于一年到头说不了几句话。不知道那些同学心里会怎么想我，大概是叹息和嘲笑吧！同时，我又是一个自尊心比较强的人，很害怕别人怎么议论我，害怕我身上的缺点被别人发现，害怕他们在背后嘲笑我，这样让我变得更加封闭，这样讳疾忌医，结果就变成了现在这样。带来的影响也很大，我不抗压，受到批评最先想到的是哭。不和别人交流，沉浸在自己的世界，没了来自别人的建议和关心，走了不少弯路，花了不少冤枉钱，交了很多智商税，甚至还养成了孤高自傲（贬义）的性格，总是认为自己的一切都是对的，也越发听不得别人的建议。</li><li>我的底子不深。看似每天忙这忙那，涉猎广泛，但真的只是每样都只懂一点点（纯事实，非谦虚），我的编程仍然像小孩子过家家一样，专业课也很拉跨。跟身边的大佬根本不在一个层次。</li></ul><p>写了那么多，是时候找找解决办法了。</p><p>。首先就是抓住重点学习。我把现阶段的重点放在C<ins>的学习上，目标是通过C</ins>深入了解编程语言，在大一学到的两门编程语言C和Python都没有认真。只是了解最基础的知识。基本上还是小白一个。所以C++要深入的学习。最起码的要求是把所有专业书籍看完，加上刷题。然后是英语</p><p>指导方案就是发展优势，提升劣势。</p><ul><li><p>明确学习目标。有一个明确的学习规划。现阶段学习效率不高的原因，总结为以下几点：</p><ul><li>没有明确的学习计划。老是想着一块抓，忽略自己的能力有限，多开根本吃不消。</li><li>缺少一套合理的规划。尝试过todo，以时间作为标准很难把握，有时候要理解一个知识点学要花费很长时间，这样就会出现文章开头描述的那种状态。同时消减学习的信心，</li><li>规划的可执行性不高。按照一些公众号文章，博主口中的说法，那英语和编程举例，首先是英语，soren老师的方法十分全面，听说读写译面面俱到，但是每一个执行起来的时间十分感人。但是精听，每天就能花费几个小时。这样做是以时间换成绩，对于英语专业的学生十分可行，但是对于计算机的学生简直要命。不仅时间长，而且枯燥无味、所以要兼顾编程和英语，这样做就是十分低效的。</li></ul></li><li><p>改变生活习惯</p><p>这个最主要是作息，这个是必须强制执行的。除特别紧急的问题。</p><ul><li>睡觉时间，安排在晚上的十一点，上学后再调整，</li><li>起床时间。定在早上的7点，意思是早上7点必须起来。</li><li>必须要娱乐时间。打游戏和看视频</li><li>打造舒适的生活学习环境</li><li>淡化无用的兴趣点，避开所有学习博主的安利</li><li>每天锻炼30分钟</li></ul></li><li><p>拓展交流圈子</p><ul><li>利用好自己手头上的交流方式。在群里发言。空间，朋友圈，电报群。</li><li>在论坛提问，讨论问题，知乎，和Stack Overflow</li><li>多加好友，多去主动交流，不能怕尬和冷场</li></ul></li><li><p>利用好自己的学习工具</p><ul><li>学习应该以iPad和window为主力，这部分主要时输入和输出，就是加工知识和输出内容，手机主要背诵和熟悉知识。找到自己最合适的学习模式。这个模式是建立在iPad和Windows软件的生态上的。</li><li>找到最适合自己的软件。目前来说我接触的软件已经完全可以实现自己全部的学习。所以拒绝接触新软件，把现有的软件细化，挑选出最适合的。找到每个软件的定位和方法。把它们总结归纳到自己的博客上。</li><li>搜素工具和求助方法</li></ul></li></ul><p>下面是系统的方法探究和全面的规划。</p><ul><li><p>学习目标上</p><p>这个分成学校的应试要求和自己的自学，这里以自学为主。</p><ul><li><p>自学</p><ul><li>C++</li><li>学习资料：《C++primer》</li><li>学习方法：看书，搜素，记笔记</li><li>软件：浏览器，MN3，OneNote，Anki</li><li>学习目标：3个月内学完</li></ul></li><li><p>应试</p><p>科目上的所有考试课</p><ul><li>网课挂着，作业能抄就抄，能水就水。</li><li>平时刷书，找到教材，花点时间看书，课后习题做做、</li><li>学习目标：数据结构，电子技术基础，汇编语言，心理学。</li><li>学习建议：找到兴趣点，看书抓住重点，找个时间集中看</li></ul></li></ul></li><li><p>软件使用上</p><ul><li><p>笔记软件</p><ul><li><p>OneNote</p><ul><li><p>优势</p><p>无限的画布，拓展性极高，可以使用合并图表法对知识进行系统的处理，插入视频，文件的功能十分强大</p></li><li><p>用途</p><p>适合对书上的知识做系统的总结，对书本外搜索到的视频文章插入整理</p></li><li><p>使用方法</p></li></ul></li><li><p>goodnote|notebality</p><ul><li><p>优势</p><p>手写笔记的福音，强大的书写体验，配合apple pencil直接王炸，代替纸质笔记本的最好帮手</p></li><li><p>用途</p><p>课堂上整理老师讲课，搜索时记录灵感</p></li><li><p>使用方法</p></li></ul></li><li><p>typora</p><ul><li><p>优势</p><p>最舒服的Markdown编辑器，实时预览的美感，所见即所得。我愿称之为地表最强！</p></li><li><p>用途</p><p>书写文章，做内容输出</p></li><li><p>使用方法</p></li></ul></li></ul></li><li><p>思维导图</p><ul><li><p>xmind</p><ul><li><p>优势</p><p>思维导图的优势不必多言，清晰明了。</p></li><li><p>用途</p><p>学习整本书后对主题进行梳理，不准备做主力使用</p></li><li><p>使用方法</p></li></ul></li></ul></li><li><p>学习内化软件</p><ul><li><p>Marginnote3</p><ul><li><p>优势</p><p>完美的学习软件，对知识拆解与消化达到了登峰造极的地步。强到不可思议！再重复一遍，苹果是神！marginnote是神!</p></li><li><p>用途</p><p>对所有书本的内化拆解，做思维导图，找知识点架构。复习卡片。</p></li><li><p>使用方法</p></li></ul></li></ul></li><li><p>搜索软件</p><ul><li><p>chorme</p><ul><li><p>优势</p><p>在搜索领域方面，谷歌是永远的爹！单从搜索引擎来说，谷歌做的无疑是最好的。</p></li><li><p>用途</p><p>有困难，找谷歌。所有问题去谷歌上找。</p></li><li><p>使用方法</p></li></ul></li></ul></li><li><p>讨论社区</p><ul><li><p>知乎|quora</p><ul><li><p>优势</p><p>很好的交流社区</p></li><li><p>用途</p><p>做讨论平台</p></li><li><p>使用方法</p></li></ul></li><li><p>Stack Overflow</p><ul><li><p>优势</p><p>程序员必用社区，你的所有问题都在这上面找的到</p></li><li><p>用途</p><p>谷歌不行的时候来这找</p></li><li><p>使用方法</p></li></ul></li></ul></li><li><p>复习软件</p><ul><li><p>anki</p><ul><li><p>优势</p><p>艾宾浩斯遗忘曲线的应用，卡片的形式，正反面的展示方法，anki就是复习记忆领域无可匹敌的存在。</p></li><li><p>用途</p><p>学习后知识点的记忆</p></li><li><p>使用方法</p></li></ul></li></ul></li></ul></li><li><p>学习方法上</p><p>这些软件每一个拉出来都是一个打十个的存在，把它们整合起来，打造学习闭环，才能使学习更加高效。下面以C++的具体学习为例展示如何打造学习闭环。</p><ul><li><p>科目：C++</p></li><li><p>资料：《C++primer》</p></li><li><p>过程</p><p>拿到C++ primer的电子书（英文版），放到MN3上去，使用MN先对内容进行批注，对不认识的单词，用黄色标注，然后通过欧陆词典查词，这个过程是连续的，这是基于苹果的分屏和MN，欧陆三者的交互实现的。然后把做好的这些标注卡片放到复习卡片组，导入到anki中，在借由ipad上的anki同步到手机中的anki上，完成对C++ primer上生词的复习。</p><p>同样的方法，可以对书中的重点，术语进行批注，然后通过学习模式做成连续的思维导图，对要识记的知识点做成复习卡片，同样的方法导入anki，在手机上复习。形成完整的学习闭环。在学习过程中，无疑会有很多不理解的地方，这些东西拿到chorme，用google搜索，找答案。找到的文章通过OneNote进行剪藏。在OneNote上进行简单的批注。学习完一定的章节后，通过MN的思维导图对章节做总结，然后导出到OneNote上，再将之前剪裁的内容通过超链接的方式插入链接到思维导图上，在使用表格合并法做知识的梳理总结。学完一本书之后同样如此。</p><p>最后到了知识的输出阶段，这个阶段分为两个方面，第一个就是知识的整理分析上，有的时候，网上中找到的答案只有一部分，或者需要做进一步的提炼总结，而又不想破坏剪藏好的文章，因为这些文章的其他部分未来也可能用的到，这时候就会用到学习的输出工具–typora，通过他来将自己通过各种途径获得的知识做进一步的总结提炼，归纳整理。然后在导入到OneNote中，以文件附件的形式链接到到整理的思维导图上。另一个方面，当需要自己写技术文章时同样使用他做笔记，上传到博客上。</p></li></ul></li><li><p>具体的学习计划</p><ul><li>按照上面的方法学习，目标是在3个月内完成C++prime的学习，通过上述软件做笔记时。标注好完成的日期和时间，知识点的出处，还要对知识点的所有总结的链接。力求一个知识点能找到出处，相关内容和所处体系。这些东西明天探索出来。</li><li>上述内容完成程度要求十分高，目的是做成一个学习库。这是十分有意义的事情。所以花费的时间不必在意。干就完了。</li></ul></li><li><p>建立健康的生活习惯</p><ul><li><p>作息时间：休息时间是11点，起床时间定在7点，睡不着的情况通过听听力解决。这个方法很有效。</p></li><li><p>舒适的学习环境、</p><p>这个重点说一下，首先，整理书桌。以少即是多为原则。桌子上摆放的只有电脑，平板。键盘。还有鼠标和一个杯子。其余物品放在抽屉里。床的位置稍向后移。给腿留下更多的伸展空间。板凳挑的调到适当位置。</p><p>然后是整理床铺。</p></li><li><p>每天一定的娱乐时间</p></li></ul><p>不积攒压力，找到一个合适的发泄口。能带来短时刺激的在我看来只有游戏，但游戏又有成瘾性的问题。那么退而求其次，用美剧和动画的方式排解压力。注意，这个娱乐是自己一定要受到刺激。也就是说，不要想着看纯英文。有中文字幕看中文，没有找资源。在没有其他事情时可以听音乐。偶尔心血来潮可以打打游戏。但频率不能太高。</p><ul><li>坚持锻练</li></ul><p>每天keep 30min，这点很方便，直接在家就可以做</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>21年暑假阶段总结</title>
      <link href="/2021/09/13/%E6%80%BB%E7%BB%93%E8%B4%B4/"/>
      <url>/2021/09/13/%E6%80%BB%E7%BB%93%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<p>暑假即将过去，说一说自己的假期感受。<br>总结来说，挺充实的。<br>干了很多自己想干的事。</p><h2 id="搭博客"><a class="markdownIt-Anchor" href="#搭博客"></a> 搭博客</h2><p>先是搭博客，去外国平台买了域名，跟着网上的教程一步一步来，不会的就去学，出问题就去搜。</p><p>必须承认，这个过程并不惬意，甚至十分折磨人。</p><p>我记得为了学git，去b站看了一个星期的教程，写了7000字的笔记；</p><p>我记得为了解决一个问题，大半夜不睡觉去和开发者联系；</p><p>我记得搭建完成后为了加上一个插件结果结构崩溃只好推到重来的崩溃；</p><p>这是一个及其无聊且折磨人的过程。但幸好 ，结果还算尽如人意，我有了自己的一方天地 。在这个空间里，畅所欲言，无忧无虑。我学到了不少知识，从版本控制到markdown再到命令行，HTML语法。我认识到了不少的朋友，有同专业的，还有已经进了大厂工作的，甚至还有自己创业的巨佬。他们有的教会了我技术 ，有的指导我前进，这些都是我收获的。</p><span id="more"></span><h2 id="视频制作"><a class="markdownIt-Anchor" href="#视频制作"></a> 视频制作</h2><p>再往后，我接触视频剪辑。开始学着做mad，先学了pr，后来为了做动画又去学了ae  ai，然后开始制作，过程一如既往的让人不舒服，为了找素材，扒变了不少网站 ，2倍速看了不知道多少部番，还记得高三那年寒假上网课想着要是能不学习一只看番该多快乐，结果现在梦想成真，发现确实很快乐。为了做效果，天天坐在电脑旁边跟着教程肝。记得视频开头那个片头 看着简单，只有5秒，做了快一个小时。还有复刻的视频，肝了一周，到现在还没做完（哭）当然了、过程虽然痛苦，但结果确实是令人满意的，学会了pr ae的基本操作 ，做出了满意的效果，完成了自己第一个自制视频。最重要的是 ，享受了创造的乐趣。这种快乐确实是无与伦比的。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>当然，还是有遗憾的，我在搭完博客，给自己做自我介绍的时候，列了四个暑假目标，包括拿驾照，学编程，学英语，练盲打。结果驾照疫情不让练，只过了科目一，编程书放在桌子上，一直吃灰。英语花200块钱报班，最后却没跟上（不过好在全是文字版，可以反复看）唯一学会的也就是还不是特别熟练的盲打了。从刚开始的想法来看，这个暑假无疑是失败的，但换个角度看，上面列举的学编程，学英语，这些都是需要长时间的积累的，不是做了就会立马出效果的，而暑假在家，本身对这些并无兴趣 ，强撑着去学反而并不快乐，甚至会适得其反。倒不如去做一些感兴趣的事。这样保证了时间的最高效利用。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 假期总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="/2021/09/13/%E5%BF%83%E7%90%86%E5%AD%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AF%BC%E8%AF%BB/"/>
      <url>/2021/09/13/%E5%BF%83%E7%90%86%E5%AD%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AF%BC%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>读书是我一直以来的憧憬，但每当我去做时却阻力重重。我以忙其他事情做借口，为自己的怠懒找理由。浪费掉了大多数可以读书的时间。所以借着立flag的机会，我决定开始我搁置了很久很久的读书计划。</p><img src="https://i.loli.net/2021/09/22/7tEalCkdIPBNp13.jpg" loading="lazy"><span id="more"></span><h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2><ul><li>这篇读书列表是趁着立flag时写下的，也想借此求证一下——真正阻碍我读书的真的是快节奏紧张的学习生活吗？</li><li>读书笔记的形式多种多样，完全照着自己的感觉来的</li></ul><h2 id="书单"><a class="markdownIt-Anchor" href="#书单"></a> 书单</h2><p>开始正式的书单前，先熬点鸡汤。推荐观看<a href="https://space.bilibili.com/517327498?spm_id_from=333.788.b_765f7570696e666f.1">罗翔</a>老师的<a href="https://www.bilibili.com/video/BV1BK411L7DJ?spm_id_from=333.999.0.0">我们为什么要读书？</a>。</p><p><strong>读书是与伟大的灵魂对话！</strong></p><p>下面开始我的书单</p><h3 id="工具书"><a class="markdownIt-Anchor" href="#工具书"></a> 工具书</h3><p>PS：这里准备了一些用的到的工具书，注意第一本！</p><table><thead><tr><th>书名（包含地址）</th><th>日期记录</th></tr></thead><tbody><tr><td><a href="https://1drv.ms/u/s!Am5BePtqKSxkhV841nmCua_JhWlF">如何阅读一本书</a>（OneNote地址，有时可能不稳定，需要fq）</td><td>21-5-13</td></tr></tbody></table><h3 id="心理学"><a class="markdownIt-Anchor" href="#心理学"></a> 心理学</h3><p>PS：这是我非常感兴趣的一个话题，书单选择的是@刘未鹏在豆瓣上的书单，名字叫做<a href="https://www.douban.com/doulist/46003/?start=0&amp;sort=time&amp;playable=0&amp;sub_type=">思维改变生活</a>，以表格的形式列出</p><table><thead><tr><th>书名（包含博客地址）</th><th>日期记录</th></tr></thead><tbody><tr><td><a href="https://liuhd.com/2021/09/13/20%E4%B8%96%E7%BA%AA%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E5%BF%83%E7%90%86%E5%AD%A6%E5%AE%9E%E9%AA%8C/">20世纪最伟大的心理学实验</a></td><td>21-8-09  ~</td></tr><tr><td>社会心理学</td><td></td></tr><tr><td>影响力</td><td></td></tr><tr><td>判断与决策</td><td></td></tr><tr><td>改变心理学的四十项研究</td><td></td></tr></tbody></table><h3 id="小说"><a class="markdownIt-Anchor" href="#小说"></a> 小说</h3><p>PS：这个部分没有具体的分类，看到哪里写哪里。</p><table><thead><tr><th>书名</th><th>日期记录</th></tr></thead><tbody><tr><td><a href="https://liuhd.com/2021/09/22/%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F/">杀死一直知更鸟</a></td><td>21-5-22  ~21-5-24</td></tr><tr><td>人间失格</td><td>21-9-25 ~21-9-27</td></tr><tr><td>房思琪的初恋乐园</td><td></td></tr></tbody></table><h3 id="传记"><a class="markdownIt-Anchor" href="#传记"></a> 传记</h3><p>PS：读别人的故事，塑自己的人生</p><table><thead><tr><th>书名</th><th>日期记录</th></tr></thead><tbody><tr><td>乔布斯传</td><td></td></tr></tbody></table><h3 id="哲学"><a class="markdownIt-Anchor" href="#哲学"></a> 哲学</h3><table><thead><tr><th>书名</th><th>日期记录</th></tr></thead><tbody><tr><td>理想国</td><td></td></tr></tbody></table><h2 id="读书进度"><a class="markdownIt-Anchor" href="#读书进度"></a> 读书进度</h2><ul><li>21-9-24<ul><li>写下这个书单列表，填上一些读过的书</li><li>心理学伟大实验：第一章读完</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/2021/09/13/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/13/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><p>这是我第一次发博客的学习文章，这个文章是我在学习git时做的笔记，为了弄懂我配了大量的图片，看完之后应该对git，github，版本控制都有一定的了解。当然这不是所谓的技术文章（事实上我现在也没能力去写技术文章），仅仅是把我的学习记录下来。文章是参考廖雪峰老师的git教程，和尚硅谷的git视频来写的。大家如果要学习的话建议去看看。</p><span id="more"></span><h2 id="git简介"><a class="markdownIt-Anchor" href="#git简介"></a> git简介</h2><h3 id="版本控制"><a class="markdownIt-Anchor" href="#版本控制"></a> 版本控制</h3><blockquote><p>什么是版本控制系统？</p><p>如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：</p><p>想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：</p><img src="https://i.loli.net/2021/07/21/pRkcDQsnYG82bv5.jpg" loading="lazy"><p>过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。</p><p>看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。</p><p>更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。</p><p>于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？</p><p>这个软件用起来就应该像这个样子，能记录每次文件的改动：</p><table><thead><tr><th style="text-align:left">版本</th><th style="text-align:left">文件名</th><th style="text-align:left">用户</th><th style="text-align:left">说明</th><th style="text-align:left">日期</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">service.doc</td><td style="text-align:left">张三</td><td style="text-align:left">删除了软件服务条款5</td><td style="text-align:left">7/12 10:38</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">service.doc</td><td style="text-align:left">张三</td><td style="text-align:left">增加了License人数限制</td><td style="text-align:left">7/12 18:09</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">service.doc</td><td style="text-align:left">李四</td><td style="text-align:left">财务部门调整了合同金额</td><td style="text-align:left">7/13 9:51</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">service.doc</td><td style="text-align:left">张三</td><td style="text-align:left">延长了免费升级周期</td><td style="text-align:left">7/14 15:17</td></tr></tbody></table><p>这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪</p></blockquote><h3 id="git概述"><a class="markdownIt-Anchor" href="#git概述"></a> git概述</h3><p>git就是一个典型的版本控制工具。</p><p>它具有以下的作用：</p><ol><li>协同修改<ul><li>实现多人并行不悖的修改服务器端的同一个文件。</li></ul></li><li>数据备份<ul><li>git不仅能够保存目录和文件的当前状态，还能够保存每一个提交后的历史状态。</li></ul></li><li>版本管理<ul><li>git采用文件系统快照的形式，实现在保存每一个版本的文件信息时不保留重复数据，可以节约存储空间，提高运行效率。</li></ul></li><li>权限控制<ul><li>对团队中的开发人员进行权限控制。</li><li>对团队外开发者贡献的代码进行审核。</li></ul></li><li>历史记录<ul><li>查看修改人，修改时间，修改内容，日志信息</li><li>将本地文件恢复到某一个历史状态。</li></ul></li><li>分支管理<ul><li>允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。</li></ul></li></ol><h3 id="git优势"><a class="markdownIt-Anchor" href="#git优势"></a> git优势</h3><ul><li>大部分操作都在本地完成，无需联网</li><li>能够保证版本信息的完整性（哈希操作）</li><li>尽可能的添加数据而不是删除或者修改（契合版本控制）</li><li>分支操作快捷流畅</li><li>与linux系统全面兼容</li></ul><h3 id="git安装"><a class="markdownIt-Anchor" href="#git安装"></a> git安装</h3><p>具体的安装教程可以参考<a href="https://git-scm.com/doc">git官方文档</a>，有问题就去谷歌搜索一下（有困难找谷歌（斜眼笑））</p><h3 id="git结构"><a class="markdownIt-Anchor" href="#git结构"></a> git结构</h3><img src="https://i.loli.net/2021/07/21/dFVSowqgktvM7OT.png" loading="lazy"><h3 id="git和代码托管中心"><a class="markdownIt-Anchor" href="#git和代码托管中心"></a> git和代码托管中心</h3><p>作用：用来维护远程库</p><ul><li>局域网环境下<ul><li>Gitlab服务器</li></ul></li><li>外网环境下<ul><li>GitHub</li><li>码云</li></ul></li></ul><h3 id="本地库和远程库"><a class="markdownIt-Anchor" href="#本地库和远程库"></a> 本地库和远程库</h3><p><strong>团队协作</strong></p><p>、<img src="/.com//zEM17gv2xkDRHAJ.png" loading="lazy"></p><p>**工作原理：**项目创建人将自己的本地库<code>push</code>到代码托管中心（远程库），任何人（有权限访问）可以将远程库<code>clone</code>到自己的本地库中，然后进行操作，但个人的修改不能直接上传到远程库，需要加入团队。然后将自己修改后的本地库<code>push</code>到远程库（由于使用git，会保留所有版本的记录），然后小组的其他成员将远程库<code>pull</code>回自己的本地库。从而实现团队之间的协同开发。</p><p><strong>跨团队协作</strong></p><img src="https://i.loli.net/2021/07/21/N29w6ZXtY3aPkSm.png" loading="lazy"><p>**工作原理：**对于团队外的成员，如果也想去参与团队的开发，可以<code>fork</code>该团队的远程库，将这个远程库传到自己的远程库中，再通过<code>clone</code>将远程库下载到本地库中，然后进行开发，再通过<code>push</code>将自己本地库<code>push</code>到自己的远程库中。然后向项目开发团队发送一个<code>push resquet</code>经由开发团队审核后可以传向开发团队的远程库，然后开发团队中的成员再<code>pull</code>到自己的本地库。</p><h2 id="git的命令行操作"><a class="markdownIt-Anchor" href="#git的命令行操作"></a> git的命令行操作</h2><h3 id="本地库操作"><a class="markdownIt-Anchor" href="#本地库操作"></a> 本地库操作</h3><h4 id="本地库的初始化"><a class="markdownIt-Anchor" href="#本地库的初始化"></a> 本地库的初始化</h4><ul><li>命令：git init</li><li>操作：在Windows上任何一个窗口打开右键，选择Git Bash Here，即可打开命令行，使用git操作，也可使用linux操作。(<a href="https://app.yinxiang.com/shard/s22/nl/31392663/d8e60561-26ee-4794-b145-16428507c8e2">常见的linux命令</a>)找到文件后输入命令git init 对创建的文件进行初始化（效果就是创造一个.git的目录）</li><li><img src="https://i.loli.net/2021/07/21/9Ji6EPIuyA7dRfO.png" loading="lazy"></li><li>注意：.git目录中存放的是本地库相关的子目录和文件，不要删除，也不要随意的修改。</li></ul><h4 id="设置签名"><a class="markdownIt-Anchor" href="#设置签名"></a> 设置签名</h4><ul><li><p>形式</p><p>用户名：tom</p><p>Email地址：goodmoring@tom.com作用：标识不同开发人员的身份</p><p>辨析：这里设置的签名和远程库登录账号没有任何关系</p><ul><li>作用：标识不同开发人员的身份</li><li>辨析：这里设置的签名和远程库登录账号没有任何关系</li><li>命令<ul><li>项目级别/仓库级别：尽在当前本地库范围内有效<ul><li>git config <a href="http://user.name">user.name</a> tom_pro</li><li>git config user.email <a href="mailto:goodMoring_pro@tom.com">goodMoring_pro@tom.com</a></li><li><img src="https://i.loli.net/2021/07/21/RaTXGsDwzqr92FP.png" loading="lazy"></li></ul></li><li>系统用户级别：登陆当前操作系统的用户范围（整个电脑）<ul><li>git config --global <a href="http://user.name">user.name</a> tom_glb</li><li>git config --global  user.email <a href="mailto:goodMoring_pro@tom.com">goodMoring_pro@tom.com</a></li><li>信息保存位置：.git/config文件</li><li><img src="https://i.loli.net/2021/07/21/ZdlJY7AbyRKjhNa.png" loading="lazy"></li></ul></li><li>级别优先级<ul><li>就近原则：项目级别优先与系统用户级别，二者都有时采用项目级别的签名</li><li>如果只有系统用户级别的签名，就以系统用户级别的签名为准</li><li>二者都没有不允许</li></ul></li></ul></li></ul></li></ul><h4 id="添加提交以及查看状态操作"><a class="markdownIt-Anchor" href="#添加提交以及查看状态操作"></a> 添加提交以及查看状态操作</h4><h5 id="状态查看查看暂存区的状态"><a class="markdownIt-Anchor" href="#状态查看查看暂存区的状态"></a> <strong>状态查看</strong>（查看暂存区的状态）</h5><p><strong>命令</strong> : <code>git status</code></p><p><strong>效果</strong>：</p><p>在git gash 中输入命令<code>git status</code>按下回车，执行效果如下</p><img src="https://i.loli.net/2021/07/21/CWzRGrIwtxhc9LM.jpg" loading="lazy"><p>使用vim 编辑器来创建一个good.txt)<img src="/.com//CWzRGrIwtxhc9LM.jpg" loading="lazy"></p><p>再次查看状态，显示有文件但未追踪，（鲜明的红色）</p><img src="/.com//eoA6Uzvf9LlWHbG.jpg" loading="lazy"><img src="https://i.loli.net/2021/07/21/1B7wsDg3WnxvSjQ.png" loading="lazy"><h5 id="提交到暂存区"><a class="markdownIt-Anchor" href="#提交到暂存区"></a> <strong>提交到暂存区</strong></h5><p><strong>命令</strong>：<code>git add</code></p><p>使用git add命令将good.txt文件提交到暂存区</p><img src="/.com//eoA6Uzvf9LlWHbG.jpg" loading="lazy"><img src="https://i.loli.net/2021/07/21/1B7wsDg3WnxvSjQ.png" loading="lazy"><p>再次查看状态：</p><img src="/.com//gV1baJn6dUs75up.jpg" loading="lazy"><img src="https://i.loli.net/2021/07/21/yuBgsT2iZDO4UvS.png" loading="lazy"><p>提示 已经将文件提交到了暂存区（一抹舒服的绿色），同时提示可以用<code>git rm --cached &lt;file&gt;</code>这个命令将文件从暂存区中移除，效果如下</p><img src="https://i.loli.net/2021/07/21/GSzrAXw82yq3tWV.png" loading="lazy"><p>再次查看状态可以发现又回到了原来未追踪的状态、（即将暂存区的文件删除）</p><h5 id="提交到本地库"><a class="markdownIt-Anchor" href="#提交到本地库"></a> <strong>提交到本地库</strong></h5><p><strong>命令：</strong><code>git commit</code></p><p><strong>效果：</strong><img src="https://i.loli.net/2021/07/21/IP2bVGdAeDTBfFY.png" loading="lazy"></p><p>git提醒你去为你的这次提交输入信息（输入信息的注释）</p><p>使用vim编辑器输入要提交的注释</p><p><strong>效果：</strong><img src="/.com//CkGYiIm5ndqJrBV.png" loading="lazy"></p><p>在第四行是根提交（<code>root commit</code>）后面是你输入的信息</p><p>第五行显示的是文件的状态，一个文件被修改，三行的内容变化</p><p>再次输入<code>git status</code>，出现<img src="/.com//se2dzVvgK6NADJu.png" loading="lazy"></p><p>第三行的<code>nothing to commit</code>表示在暂存区中没有可以提交的文件而<code>working tree clean</code>字面意思，工作树是干净的，也是没有东西可提交的意思</p><p>使用vim编辑器对提交到本地库中的文件进行修改，加上一行的u</p><p>用<code>git status</code>查看状态</p><p><strong>效果：</strong><img src="/.com//dqD2Vyv4ONPxAFK.png" loading="lazy"></p><p>可以看到git已经检测到你的修改<code>modified</code>，git同样提示可以使用<code>git add</code> 命令去<code>update</code>（<strong>这里注意这个命令和没有提交时的名利有一点不同，之前是<code>track</code>，现在是<code>update</code>，一个是在未提交时追踪，一个是提交后更新</strong>（<strong><code>注意这里的提交是到暂存区而不是本地库</code></strong>））</p><p>git同时还提示可以使用<code>git restore</code>去重置回原来的版本</p><p>最后一行的<code>and/or</code>表示可以使用git add 先将文件提交到暂存区，然后<code>git commit</code>提交到本地库，或者使用<code>git commit -a</code>直接将其提交到本地库</p><p><strong>注</strong>：在提交文件到本地库的操作中 (<code>git commit</code>)，可以使用<code>git commit -m</code>命令直接在后面输入注释内容，无需再进入vim编辑器</p><p><strong>效果：</strong><img src="/.com//ONLEyrKIW69C8Rx.png" loading="lazy"></p><p>第二行由根目录变成了一个其他目录</p><p>第三行表示状态：有一行的内容被修改，一个文件有改变</p><h5 id="img-srcgit学习笔记mv5ndxeamowjxy4png"><a class="markdownIt-Anchor" href="#img-srcgit学习笔记mv5ndxeamowjxy4png"></a> <img src="/.com//Mv5nDXeAmoWjxY4.png" loading="lazy"></h5><h4 id="版本的前级和后退"><a class="markdownIt-Anchor" href="#版本的前级和后退"></a> 版本的前级和后退</h4><p>版本的前进和后退是git实现项目管理的最重要的操作。</p><p>原理：git进行版本控制的原理主要是通过HEAD头指针的移动来实现的</p><h5 id="版本记录的查看"><a class="markdownIt-Anchor" href="#版本记录的查看"></a> <strong>版本记录的查看</strong></h5><p><strong>命令</strong>：<code>git log</code></p><p><strong>效果：</strong><img src="/.com//SXY8lRx2FEWJgrs.png" loading="lazy"></p><p>可以从效果中看到提交的索引（commit 后面的一大串）和一个HEAD指针指向的分支（master）</p><p>还有就是作者，提交日期，以及提交时的注释。</p><h5 id="其他查看方法"><a class="markdownIt-Anchor" href="#其他查看方法"></a> <strong>其他查看方法</strong></h5><p><strong>命令</strong>：<code>git log -- pretty=one</code></p><p><strong>效果：</strong></p><img src="https://i.loli.net/2021/07/21/DiLdgzM3Hl4vEcA.png" loading="lazy"><p>将每次的信息缩减值一行</p><p><strong>命令:</strong><code>git log --oneline</code> (注意只能看见当前版本前的版本，无法回到以后的版本)</p><p><strong>效果：</strong><img src="/.com//DiLdgzM3Hl4vEcA.png" loading="lazy"></p><p>将索引的哈希链缩的更短、</p><p><strong>命令：</strong><code>git reflog</code>（最常用）</p><p><strong>效果：</strong><img src="https://i.loli.net/2021/07/21/ZcMvJHmGRLDrsK5.png" loading="lazy"><br><img src="/.com//y5lekuNOVRYQ1Ho.png" loading="lazy"></p><p>在oneline基础上显示移动至当前版本所需的步数</p><p>HEAD@{移动到当前版本所需的步数}</p><h5 id="版本的前进和后退的操作"><a class="markdownIt-Anchor" href="#版本的前进和后退的操作"></a> <strong>版本的前进和后退的操作</strong></h5><h6 id="基于索引值操作"><a class="markdownIt-Anchor" href="#基于索引值操作"></a> <strong>基于索引值操作</strong></h6><p><strong>命令：</strong><code>git reset --hard &lt;index&gt;</code></p><p><strong>效果：</strong><img src="/.com//CWeyXcMbuVLdGp7.png" loading="lazy"></p><p>在使用<code>git reflog</code>查看</p><p>!<img src="/.com//HBYbqzRpka9DnP1.png" loading="lazy"></p><p>可以看到指针已经指向了要索引的地址，即实现了版本的前进和后退操作</p><p>**注：**在输入索引值时，只要选中就进行了复制，可以直接粘贴下来</p><h6 id="使用符号"><a class="markdownIt-Anchor" href="#使用符号"></a> <strong>使用<code>^</code>符号</strong></h6><p><strong>特点</strong>：只能后退</p><p>可以使用<code>git log --onelline</code>更加有效</p><img src="https://i.loli.net/2021/07/21/VCD68HgmhJe15Sx.png" loading="lazy"><p><strong>命令</strong>：<code>git reset --hard HEAD ^</code>注意一个<code>^</code>表示后退一个版本</p><img src="https://i.loli.net/2021/07/21/18ATYfpzLW2NaxX.png" loading="lazy"><h6 id="使用~符号"><a class="markdownIt-Anchor" href="#使用~符号"></a> <strong>使用<code>~</code>符号</strong></h6><p><strong>特点</strong>，同样只能用来回退</p><p>用法是将<code>^</code>符号的个数变成<code>~ &lt;number&gt;</code></p><p><strong>命令</strong>：<code>git reset --hard HEEAD ~n</code></p><h6 id="hardsoft和mixed参数的区分"><a class="markdownIt-Anchor" href="#hardsoft和mixed参数的区分"></a> <strong>hard，soft，和mixed参数的区分</strong></h6><p>hard soft和mixed都是git reset命令的参数</p><p>首先介绍一个git命令：<code>git help</code>这是一个帮助命令，在后面可以输入操作命令去查看命令参数的描述，这个文档是在安装git时就内置在安装包里面的，使用 git help命令可以直接打开相应的文档查看、</p><p><strong>–soft</strong></p><p>文档描述</p><blockquote><p>Does not touch the <strong>index file</strong> or the <strong>working tree</strong> at all (but resets the head to <code>&lt;commit&gt;</code>, just like all modes do). This leaves all your changed files “Changes to be committed”, as <code>git status</code> would put it.</p></blockquote><p>看文档可以知道 <code>--soft</code> 参数不会去改变工作区和暂存区的内容，他改变的仅仅是本地库中的内容，下面来实际操作一下。</p><p>首先看一下没使用reset之前本地库的内容</p><img src="https://i.loli.net/2021/07/21/qT7wctH4bdYkeVL.png" loading="lazy"><p>然后看一下工作区的内容</p><img src="https://i.loli.net/2021/07/21/kdQBiq1rHVWCcDE.png" loading="lazy"><p>可以看到这里工作区和本地库的内容是一一对应的</p><p>然后我们使用<code>--soft</code>参数将本地库的内容索引到另一个版本</p><img src="https://i.loli.net/2021/07/21/7FHpzUADVGRQcoh.png" loading="lazy"><p>在使用<code>git reflog</code>查看本地库中的内容</p><img src="/.com//kdQBiq1rHVWCcDE.png" loading="lazy"><img src="https://i.loli.net/2021/07/21/2dei1zP9TgmVkMn.png" loading="lazy"><p>查看工作区</p><img src="https://i.loli.net/2021/07/21/kdQBiq1rHVWCcDE.png" loading="lazy"><p>可以看到本地库的指针已经发生变化，但工作区的内容仍未改变</p><p>用<code>git status</code>查看一下暂存区的状态</p><img src="https://i.loli.net/2021/07/21/yuBgsT2iZDO4UvS.png" loading="lazy"><p>看到的是绿色的内容，说明工作区和暂存区的内容是保持一致的</p><p>这里留个问题：为什么在改变本地库后，原来已经提交后的暂存区却能被<code>git status</code>找出来而且判断已经被修改了呢？</p><p><strong>–mixed</strong></p><p>文档描述</p><blockquote><p><strong>Resets the index but not the working tree</strong> (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action.</p></blockquote><blockquote><p>If <code>-N</code> is specified, removed paths are marked as intent-to-add (see <a href="git-add.html">git-add(1)</a>).</p></blockquote><p>可以看到<code>--mixed</code>参数改变的是本地库和暂存区的内容，但并没有改变工作区的内容，下面进行实操</p><img src="https://i.loli.net/2021/07/21/yuBgsT2iZDO4UvS.png" loading="lazy"><img src="/.com//qT7wctH4bdYkeVL.png" loading="lazy"><img src="https://i.loli.net/2021/07/21/kdQBiq1rHVWCcDE.png" loading="lazy"><p>在没有使用<code>git reset</code>时，一切还是保持老样子，工作区，暂存区和本地库是保持一致的</p><p>然后使用<code>--mixed</code>参数进行操作</p><img src="https://i.loli.net/2021/07/21/qFBDAfEWnYp7mjy.png" loading="lazy"><p>查看一下暂存区的状态</p><img src="https://i.loli.net/2021/07/21/LP71ASlvkgfzRhO.png" loading="lazy"><p>这里出现了红色的字，表示的是暂存区和工作区没有保持一致，也就是说，暂存区和本地库都改变了，但工作区没有变化、</p><p><strong>–hard</strong></p><p>文档描述</p><blockquote><p><strong>Resets the index and working tree.</strong> Any changes to tracked files in the working tree since <code>&lt;commit&gt;</code> are discarded.</p></blockquote><p>可以看出<code>--hard</code>参数是把三者都重置到了要重置的版本上、这个参数是十分快捷的，要想回退或前进版本，直接就可以使用这个参数，一步到位，不需要考虑暂存区，工作区是否也跟着前进和后退了，所以hard参数是最方便也是最常用的。</p><h6 id="删除文件的找回"><a class="markdownIt-Anchor" href="#删除文件的找回"></a> <strong>删除文件的找回</strong></h6><p>在使用git时，如果不小心将文件从工作区删除了，也是可以用git找回的，但是有一个前提条件，就是必须把文件的操作信息存到本地库中去，也就是说，你在删除前使用<code>git add</code> 和 <code>git commit</code>将文件提交到了本地库。这样你就可以用版本回退的方式找回自己的文件。</p><p>因为内容和前面的回退操作比较相同，这里就不实际操作了，（主要是怕麻烦   斜眼笑.jpg）</p><p>但是可以看<a href="https://www.bilibili.com/video/BV1pW411A7a5?p=20">这个视频</a>，上面有详细的操作</p><h6 id="比较文件的差异"><a class="markdownIt-Anchor" href="#比较文件的差异"></a> <strong>比较文件的差异</strong></h6><p>git是可以去比较不同版本之间文件的差异的，具体的命令是<code>git diff</code>，下面我就来实际操作一下。</p><p>首先，创建一个新的文档，提交到本地库</p><img src="https://i.loli.net/2021/07/21/4ohFcZSrasPYMGB.png" loading="lazy"><p>然后对该文档进行修改</p><img src="https://i.loli.net/2021/07/21/tIPdaRXpuG1zqFM.png" loading="lazy"><p>我修改了apple.txt文档，在第三行上加入了@@@@@</p><p>下面使用<code>git diff</code>命令去比较文档</p><img src="https://i.loli.net/2021/07/21/ZYnI7RkqzaDA9C8.png" loading="lazy"><p>可以看到使用<code>git diff</code>命令后，文档和<strong>暂存区</strong>的文档进行了比较，比较出了第三行少了一行apple ，但多了一行apple@@@@@。</p><p>红色的前面带的是<code>-</code>号，表示的是原文档与要比较的文档之间少的内容。</p><p>绿色的前面带的是<code>+</code>号，表示的是原文档与要比较的文档之间多的内容。</p><p>如果使用<code>git add</code>将文件提交到的暂存区，在使用<code>git diff</code>进行比较，是无法比较出差异的，这就说明了<code>git diff</code>这个命令在未加参数时表示的是与暂存区的比较</p><p><code>git diff</code>命令也可以和本地库的历史版本进行比较，这个后面需要加上HEAD的参数，表示与本地库中HEAD指针指向的版本之间进行比较。</p><img src="https://i.loli.net/2021/07/21/KPOIydciA893fW4.png" loading="lazy"><h4 id="git的分支"><a class="markdownIt-Anchor" href="#git的分支"></a> git的分支</h4><h6 id="为什么git会有分支"><a class="markdownIt-Anchor" href="#为什么git会有分支"></a> <strong>为什么git会有分支</strong></h6><p>在版本控制的过程中，会有多个项目同时推进的情况，这时候就要用到分支。</p><p>所以分支就是<strong>在版本控制中，使用多条线同时推进多个任务</strong>，下面用一个图来说明：</p><img src="https://i.loli.net/2021/07/21/jrfve4oM9qUOwgi.png" loading="lazy"><p>假设我们要开发一个项目，并且使用git作为我们版本控制的工具，开始我们会有一个master主干，我们的第一代项目在这个主干上。有了一代产品，我们就想在产品上多加一些新的功能。我们准备为我们的产品开发一个主题，于是我们就多了一条线，命名为feature_blue表示我们想去开发一个blue主题。然后我们将我们的主干上的版本拉到我们这条分支上，就是将master的版本复制到feature_blue上，这时两条线是互不干扰的，可以同时再进行开发，在blue线上，我们是基于主干上的一代进行开发的，在开发完成之后（开发过程中支线上可以有多个版本），在去把支线上的版本与主线上的版本进行合并。这样我们就基于一代的产品上开发出了带有blue主题的二代版本。同样的方法，我们可以再开一条线，为我们的版本开发出一个小游戏feature_game。</p><p>同时，分支对版本的修复与维护也十分方便。假设我们的产品现在出了个bug，我们可以开一条线hot_fix去修复bug，我们把master的内容拉到hot_fix上，然后在hot_fix上去进行修复，再将修复好的版本合并到master上，这样可以保证在主线项目正常运行的基础上去对其进行修复。</p><h6 id="分支的好处"><a class="markdownIt-Anchor" href="#分支的好处"></a> <strong>分支的好处</strong></h6><ul><li>分支可以同时并行推进多个功能的开发，提高开发效率。</li><li>各个分支在开发过程中，如果一个分支开发失败，不会对其他分支有任何影响，失败的分支删除重新开始即可。</li></ul><h6 id="分支的实际操作"><a class="markdownIt-Anchor" href="#分支的实际操作"></a> <strong>分支的实际操作</strong></h6><h6 id="分支的创建查看及转换"><a class="markdownIt-Anchor" href="#分支的创建查看及转换"></a> <strong>分支的创建查看及转换</strong></h6><p>首先用<code>git status</code>看一下</p><img src="https://i.loli.net/2021/07/21/hw82cimjJ6z9Vsf.png" loading="lazy"><p>可以看到git在刚创建是就会有一个主干分支master，而且现在就在这个master分支上，</p><p>我们可以使用<code>git branch -v</code>去查看在这个项目上所有的分支</p><p>使用<code>git branch</code>去创建一个新的分支hot_fix（<strong>注意创建好一个分支就已经把master分支上的项目复制过来了</strong>）</p><p>使用<code>git checkout</code>去转换分支</p><img src="https://i.loli.net/2021/07/21/NCzRFt6Kvb8Xx3G.png" loading="lazy"><img src="https://i.loli.net/2021/07/21/HXdV51PQBqLv8rF.png" loading="lazy"><h6 id="分支的合并"><a class="markdownIt-Anchor" href="#分支的合并"></a> <strong>分支的合并</strong></h6><p>我们对hot_fix分支上的apple.txt文件进行了修改，在通过<code>git add</code> <code>git commit</code>把它提交到了本地库</p><p>这样hot_fix相对于master就快了一步，我们将hot_fix合并到master上。</p><ul><li>第一步：切换到接受修改的分支（被合并，要增加新内容）上<ul><li><code>git checkout</code>[被合并分支名]</li></ul></li><li>执行<code>merge</code>命令<ul><li><code>git merge</code>[有新内容的分支名]</li></ul></li></ul><img src="https://i.loli.net/2021/07/21/vRStxVhM2gXUI68.png" loading="lazy"><h6 id="冲突的解决"><a class="markdownIt-Anchor" href="#冲突的解决"></a> <strong>冲突的解决</strong></h6><p><strong>为什么会产生冲突</strong></p><p>分支在合并时，如果去合并的分支比被合并的分支进度快，而且前面的版本是相同的（相同文件的相同位置，并且内容一致），那么分支合并就是直接合并的（将要合并的版本合并到被合并的版本上，都变成了要合并的那个版本），但是如果合并之前的版本是不同（相同文件的相同位置，内容不一致）的，那么就会产生冲突，因为git无法判断哪一个版本要留下，这时git会发出提醒，让开发者去决定。</p><p>下面来实操一下</p><p>现在我们有两个分支，master和hot_fix，每个分支都用两个文件good.txt和apple.txt，我们使用vim编辑器去改变good.txt的内容，让他们中的同一行出现不同的输入。然后对他们进行merge合并</p><img src="https://i.loli.net/2021/07/21/Mb73cLICRAVTtKF.png" loading="lazy"><p>git提示自动合并失败，需要进行手动合并，并且最右边的（merge）变成了（master|MERGEING）</p><p>这时使用vim编辑器打开good.txt</p><img src="https://i.loli.net/2021/07/21/cNwi51YAnSC2Rto.png" loading="lazy"><p>发现good.txt里面多了几行，其中上面的</p><p>&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><p>bbbbbb edit by masteri</p><p>== == ==</p><p>表示的是要合并的分支（master）的冲突的内容</p><p>下面的表示的是去合并的分支（hot_fix）的从图的内容</p><p>这时可以再vim编辑器中直接去修改，最后得到最终版本即可</p><p>修改完成后用`git status查看一下状态</p><img src="https://i.loli.net/2021/07/21/FAWKYsL4UuTH9Vc.png" loading="lazy"><p>这时表示暂存区和工作区的文件不同，</p><p>可以用<code>git add</code> <code>git commit</code>去提交到本地库，<strong>注意在用<code>git commit</code>操作时后面不要跟文件名，否则会出现错误</strong></p><h4 id="git基本原理"><a class="markdownIt-Anchor" href="#git基本原理"></a> git基本原理</h4><p>在介绍git的基本原理之前，先了解一个概念：<strong>哈希</strong></p><h6 id="哈希是什么呢"><a class="markdownIt-Anchor" href="#哈希是什么呢"></a> <strong>哈希是什么呢?</strong></h6><p>先看一下维基百科的定义</p><blockquote><p><strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。</p></blockquote><p>从上面的定义我们知道，哈希是通过一系列复杂的计算，将任何一种数据通过算法的计算输出成一种固定格式的数据。它具有以下特点：</p><img src="https://i.loli.net/2021/07/21/6m7VxeYzHTDAwvZ.png" loading="lazy"><p>因为这些特点，哈希具有很多用途。</p><p>最常用的是确保传输数据的准确性，如果数据在传输过程中出现了一点错误，那么使用同一种哈希算法的结果就会天差地别。因此可以通过哈希算法可以检验在数据传输过程中是否被篡改。</p><h6 id="git的数据存储机制"><a class="markdownIt-Anchor" href="#git的数据存储机制"></a> <strong>git的数据存储机制</strong></h6><img src="https://i.loli.net/2021/07/21/l5KyfAh6Dnge81W.png" loading="lazy"><h6 id="git的分支管理"><a class="markdownIt-Anchor" href="#git的分支管理"></a> <strong>git的分支管理</strong></h6><h4 id="远程库的操作"><a class="markdownIt-Anchor" href="#远程库的操作"></a> 远程库的操作</h4><p>git远程库的操作主要是git和代码托管中心GitHub共同运行的。</p><p>所以我们要了解GitHub的相关操作。</p><h5 id="github的注册"><a class="markdownIt-Anchor" href="#github的注册"></a> <strong>GitHub的注册</strong></h5><p>可以参见具体的<a href="https://docs.github.com/cn/github/getting-started-with-github/signing-up-for-github/signing-up-for-a-new-github-account">官方文档</a>  不过我相信这点肯定难不倒大家。</p><h5 id="github的使用"><a class="markdownIt-Anchor" href="#github的使用"></a> <strong>GitHub的使用</strong></h5><p>我们先来回顾一下git协同开发的流程</p><blockquote><img src="/.com//image-20210711151558855.png" alt="image-20210711151558855" style="zoom: 25%;" loading="lazy"><p>**工作原理：**项目创建人将自己的本地库<code>push</code>到代码托管中心（远程库），任何人（有权限访问）可以将远程库<code>clone</code>到自己的本地库中，然后进行操作，但个人的修改不能直接上传到远程库，需要加入团队。然后将自己修改后的本地库<code>push</code>到远程库（由于使用git，会保留所有版本的记录），然后小组的其他成员将远程库<code>pull</code>回自己的本地库。从而实现团队之间的协同开发。</p><img src="/.com//image-20210711151842504.png" alt="image-20210711151842504" style="zoom:25%;" loading="lazy"><p>**工作原理：**对于团队外的成员，如果也想去参与团队的开发，可以<code>fork</code>该团队的远程库，将这个远程库传到自己的远程库中，再通过<code>clone</code>将远程库下载到本地库中，然后进行开发，再通过<code>push</code>将自己本地库<code>push</code>到自己的远程库中。然后向项目开发团队发送一个<code>push resquet</code>经由开发团队审核后可以传向开发团队的远程库，然后开发团队中的成员再<code>pull</code>到自己的本地库。</p></blockquote><p>依照这个流程我们梳理一下步骤</p><h5 id="对于团队开发"><a class="markdownIt-Anchor" href="#对于团队开发"></a> 对于团队开发</h5><p>首先由项目创建人创建一个项目（本地库），然后通过<code>git init</code>    <code>git add</code>     <code>git commit</code>去提交到本地库，流程与前面没有差别，但这是使用的是全局化的签名，无需再设置新的项目签名。</p><h6 id="创建github远程库"><a class="markdownIt-Anchor" href="#创建github远程库"></a> <strong>创建GitHub远程库</strong></h6><p>本地库创建好之后，我们需要设置远程库，具体的做法是在<a href="https://docs.github.com/cn/github/getting-started-with-github/quickstart/create-a-repo">GitHub上创建一个仓库</a>。</p><p>使用<code>git push</code>操作去将本地库push远程库</p><p>想要push操作，就一定要知道远程库的地址，在GitHub上创建地址后，我们可以在code哪里找到创建仓库的http和ssh地址，这个地址就是远程库的地址。</p><p>我们先用http地址连接到远程库</p><p>我们从code哪里将项目地址复制下来，但是网址很长，git提供了一个命令去给地址别名，</p><p>使用<code>git remote -v</code>查看地址的别名</p><p>使用 <code>git remote add &lt;别名&gt; &lt;地址&gt;</code></p><p>这是再次使用<code>git remote -v</code>查看，可以看到两个地址</p><img src="https://i.loli.net/2021/07/21/ytzwV6319emGIYQ.png" loading="lazy"><p>其中<code>fetch</code>用于取回，<code>push</code>用于推送</p><h6 id="向远程库推送"><a class="markdownIt-Anchor" href="#向远程库推送"></a> 向远程库推送</h6><p>然后使用<code>git push</code>命令推送，注意推送时需要指出<strong>别名</strong>和要<strong>推送的分支</strong></p><img src="https://i.loli.net/2021/07/21/AN45p6IUJSyGXsh.png" loading="lazy"><p>按下回车键，这是会弹出GitHub登录的窗口，输入自己的GitHub账号</p><p>这样就把本地的修改推送到了远程库</p><h6 id="从远程库克隆"><a class="markdownIt-Anchor" href="#从远程库克隆"></a> 从远程库克隆</h6><p>那别人怎么将远程库clone到自己的本地库中呢？</p><p>我们可以使用<code>git clone &lt;地址&gt;</code>命令去将远程库克隆到本地库。</p><p>由于是读取操作，所以无需登陆账号</p><p>在执行完命令后，git会自动下载远程库中的内容，克隆出的本地库与远程库是一模一样的（包括文件，初始化，分支，和别名）</p><h6 id="团队之间的修改"><a class="markdownIt-Anchor" href="#团队之间的修改"></a> 团队之间的修改</h6><p>别人clone到本地库中做出修改，如果想要push到远程库，就需要项目创建人邀请加入团队。（具体的操作可以在google上查教程</p><p>）邀请成功后就可以将更新后的项目push到远程库了。</p><p>那么项目中的其他人可以将更新的版本<code>pull</code>到自己的本地库，</p><p><code>pull</code>有以下操作：</p><p><code>git fetch &lt;地址&gt; &lt;分支&gt;</code></p><p>fetch是不会直接修改本地库的文件，相当于把远程库的分支下载下来，</p><p>我们可以用<code>checkout</code>去检查。</p><p>然后使用<code>git merge&lt;地址别名|远程分支名&gt;</code></p><p>这两个操作和直接使用<code>git pull</code>命令是一样的。</p><p>这样同样会有另外的一个问题：怎样解决冲突?</p><p>如果双方修改了同一个项目同一个位置的不同内容，那么在往远程库push是就会发生冲突，GitHub默认是按照时间来判断的，也就是说如果两个人都开发了新版本，最快提交的会直接推送成功，而另一个如果有冲突就会push失败。这是就要把上一个人更新后的远程库pull到本地库，这是就会进入冲突状态，处理方法与前面处理分支方法类似。</p><h5 id="对于跨团队协作"><a class="markdownIt-Anchor" href="#对于跨团队协作"></a> 对于跨团队协作</h5><p>不同团队之间共同开发时，只需要在GitHub上将远程库<code>fork</code>下来，这样就在自己的远程库中存储下了项目，修改就与前面完全相同。</p><p>如果想要提交到原开发团队，需要在GitHub上发出<code>pull request</code>，等待原项目创建负责人审核即可。</p><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>这个文章是我第一次写，无论是排版布局，还是内容深度，严谨性都有很多不足之处，而且配大量图算是一个失智之举，让这篇文章看起来十分冗杂，以后还是多用代码块来说明问题吧，这样不仅展示效果好，还附带有思考的空间。一味的将结果呈现出来，那是教程视频来干的事情，而不是博客文章。这篇算是一次试水，以后有时间我会将这些毛病改掉，给大家呈现出更精致，更适用的git笔记！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git|github </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《20世纪最伟大的心理学实验》</title>
      <link href="/2021/09/13/20%E4%B8%96%E7%BA%AA%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E5%BF%83%E7%90%86%E5%AD%A6%E5%AE%9E%E9%AA%8C/"/>
      <url>/2021/09/13/20%E4%B8%96%E7%BA%AA%E6%9C%80%E4%BC%9F%E5%A4%A7%E7%9A%84%E5%BF%83%E7%90%86%E5%AD%A6%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<img src="https://i.loli.net/2021/09/22/zSVFroOl1YEW9Is.jpg" loading="lazy"><span id="more"></span><h2 id="作者简介"><a class="markdownIt-Anchor" href="#作者简介"></a> 作者简介</h2><blockquote><p>劳伦•斯莱特</p><p> 哈佛大学心理学硕士，波士顿大学教育学博士，既是一名心理学家，也是一名专业作家。</p><p> 她的写作风格受到学术的批评，但深受普通读者的喜爱。这本书被誉为“沟通学术与大众最重要的作品”。</p><p> 她的作品获奖颇丰。其著述曾获选收录于《全美最佳论文》、《全美最佳科学著作》、《全美最佳杂志论文》等论文选集。</p></blockquote><h2 id="内容简介"><a class="markdownIt-Anchor" href="#内容简介"></a> 内容简介</h2><blockquote><p>《20世纪最伟大的心理学实验》是惊悚有趣的心理学实验，探索人类心灵的十大发现，“普通心理学”课程必读。</p><p>作者重新诠释了20世纪心理学探索人类心灵的非凡成就，以10个设计精巧的天才实验为例，结合小说、传记、采访等多种体裁，让你仿佛与作者、实验当事人共处一室，倾听他们的生命叙事，深刻体会心理实验背后的深邃涵义。</p><p>作者剖析议题深入详尽呈现清晰实像，让单调冰冷的科学实验，得以展现丰富感性的内涵。对于人性本质的优劣，不仅见解独到，更发人深省。</p></blockquote><h2 id="读书笔记"><a class="markdownIt-Anchor" href="#读书笔记"></a> 读书笔记</h2><h3 id="第一章打开斯金纳箱"><a class="markdownIt-Anchor" href="#第一章打开斯金纳箱"></a> 第一章：打开斯金纳箱</h3><p>先提一个耳熟能详的人物，巴普洛夫大家都听过，俄国著名的生化学家。</p><p>不出意外的话，大家对他的了解都来自于高中生物书上那句“巴普洛夫的感慨”（什么，你说你没印象。没关系，我来帮你回忆回忆( ‵▽′)ψ）</p><p><img src="https://i.loli.net/2021/08/09/Wk5QVE3G6lem9IU.png" alt="Audits - Lighthouse" loading="lazy"><em>是不是想起了被高中课本支配的恐惧了呢┏(＾0＾)┛</em></p><p>当然，巴普洛夫并非只是这样“无能狂怒”，要不然也不会是“最伟大的生理学家”了，巴普洛夫最著名的还是那条“<a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%94%AB%E6%B4%9B%E5%A4%AB">巴普洛夫的狗</a>”，通过对狗唾液腺的研究，巴普洛夫发现了“经典的条件反射”。</p><blockquote><p>简言之，即动物既有的本能反应，如：眨眼、惊吓、流口水等，可用人为的方式加以控制，使其伴随新刺激出现。在巴甫洛夫著名的实验中，铃声是新刺激，狗听到铃声，就想到食物，所以一听到铃声就会流口水</p></blockquote><p>虽然现在你可能不以为意，但在当年，这项发现可是广受各界瞩目，讨论的热烈程度不逊于原子融合、太阳位置恒定等重大科学突破。在此之前，人类从不知道，**许多我们认为受心智主导的反应其实与生理学有着密切关系，我们以前总以为与生俱来的动物本能无法改变，事实上却具有高度可塑性。**巴甫洛夫流口水的狗，颠覆了长久以来被你我视为理所当然的两个观念。</p><p>当然，我们现在并不关心那只被“玩坏”的可怜的狗狗。</p><p>你只需要知道，狗在听到铃声后的唾液分泌其实是一种本能反应，狗看到食物就会馋的流口水，这并不是狗控制的了的，完全出于本能，而巴普洛夫的实验证明了，在足够的刺激下，这种本能的反射会在人为的方式下激发。</p><p>而今天提到的斯金纳，那可就大不一样了。</p><p><strong>他带来了那个魔术的“箱子”。</strong></p><p>关于斯金纳的生平，我给大家放在<a href="https://zh.wikipedia.org/wiki/%E4%BC%AF%E5%B0%94%E8%B5%AB%E6%96%AF%C2%B7%E5%BC%97%E9%9B%B7%E5%BE%B7%E9%87%8C%E5%85%8B%C2%B7%E6%96%AF%E9%87%91%E7%BA%B3">这里</a>，有兴趣的可以了解一下。</p><p>斯金纳是巴普洛夫的粉丝，他对巴普洛夫的唾液腺研究十分感兴趣，但他的目标更远大，既然可以控制特定的腺体，那么有没有可能控制整个生物体呢？人的行为根据环境做出来的，与狗本能的流口水不同，人的这种反应是一种有意识的行为。那么，有没有可能人也可以经过训练，主动的做出某个非本能的动作呢？</p><blockquote><p>例如，要某人把头向右转，且持续给予奖赏，不久之后，此人是否就会牢记这个动作，持续向右看？若有这种可能，那么哪些行为可以比照办理呢？我们能像马戏团的动物那样，轻松优雅地跳过火圈吗？</p></blockquote><p>带着这个疑问，斯金纳设计出了一个实验操作箱。开始了对老鼠的研究。</p><blockquote><p>这个箱子以压缩空气为运转动力，由各式零件齿轮组成机械装置，可依实验者设定，释放出特定的奖惩物。</p></blockquote><p>实验是这样的：</p><blockquote><p>他把老鼠放到箱子里，实验就此展开。经过很长一段时间，事实上是好几年，他发现这些大脑如豆子般大的老鼠，为了取得作为奖赏的食物，可以很快学会按压控制杆。<strong>巴甫洛夫强调前刺激（prior stimulus），即事先出现的铃声，会让动物产生何种反应。斯金纳则注重结果（consequence），即事后给予食物，对动物的行为有何影响。</strong><br>斯金纳的实验和巴甫洛夫早期的研究差别不大，结果并不令人意外。美国心理学家桑代克（Thorndike）也曾做过类似实验，关在木箱里的猫偶然踩到某个踏板，而获得一些奖赏，之后它便会刻意去踩踏板。斯金纳的实验明显沿袭自桑代克。然而斯金纳的成果远超过这两个人。他首先让老鼠意外踩到控制杆，掉出食物颗粒，原先无意间的举动遂转变为刻意的行为。斯金纳进一步实验，将奖赏移除或改变出现频率，观察这对老鼠行为有何影响，最后他终于归纳出放诸四海皆准的人类行为定律，至今依然颠扑不破。<br>一开始只要老鼠压杆，就可以得到食物，后来斯金纳改变他所谓的固定比例（fixed-ratio）的奖赏。老鼠若要获得奖赏，必须压杆3次、5次，或是20次。想象自己是只老鼠，一开始每次压杆都有东西吃。接着你压一下控制杆，没有食物，再压一次，还是没有东西，你又压了一次，银色喷管里终于掉出食物，你吃掉食物后走开。过一会儿，你又想吃东西了，这回你不需用脚爪按一次停一下，一口气连按三次就好了。强化物出现的频率改变了动物的反应方式。<br>除了固定比例的奖赏，斯金纳也尝试把奖赏移除，观察结果。奖赏移除的实验中，斯金纳移除所有的强化物，最后他发现如果他停止给老鼠食物，老鼠逐渐不去压杆，最后就算听到喷管里有东西沙沙作响，它们也无动于衷。斯金纳又开始思考：**老鼠在固定比例奖赏情境下，学会新反应需要多长时间？奖赏突然移除后，经过多久才会停止这种反应？**于是他在箱子上设置记录器，精确测量在不同情境条件下的频率变化，并绘制图表，获得具体数据。这些资料不仅显示有机体的学习模式，也可作为预测并控制学习结果的依据。</p></blockquote><p>斯金纳的研究并未停止</p><blockquote><p>他进而研究其所谓的不固定的强化（variable schedules of reinforcement），且获得了最为重要的发现。他改变压杆获得食物奖励的比例，多数时候老鼠空手而回，但也许在压杆第40或60次时，突然获得食物奖励。一般人直觉地认为，随机且间隔如此长的奖赏，会使老鼠对获得奖赏不抱希望，致使压杆行为消失。事实却并非如此。斯金纳发现**，间歇给予食物奖赏的方式，反而让这些老鼠像染上毒瘾一样，不断压杆，不论能否得到奖赏。斯金纳还将固定比例（如压杆4次就给予食物）与不规则的间歇奖赏进行对比，他发现奖赏间隔不规则的情境下，消除既有行为需时最久。**</p></blockquote><p>斯金纳的这项发现被称作“<strong>间歇性强化</strong>”，这个发现可以解释很多我们现实中的愚蠢行为，为什么有的人身心健全，却在烟雾弥漫的赌场中散尽全部的家财，最终身败名裂。为什么我们的好友会痴痴地守着微信QQ，苦候恶劣男友偶尔心血来潮打来的电话。为什么男同学对基金情有独钟。为什么吴签明知诱骗未成年人犯法，还要喊着“我自己会进监狱”而持续自己的“三分钟行为”，最后领了牢饭。<strong>我们做出的这些蠢事，即使得不到回报，却仍然执迷不悟。就是因为这是一种心理作用，是间歇性强化。</strong></p><p>由此，斯纳金发展出了<strong>行为科学</strong>，他主张我们应当正确评价环境所施加的巨大控制（影响），而遵循特定方式建构环境，使其给予我们“正强化”，也就是要引导我们言行合宜，适应环境，发挥创意。斯金纳呼吁社会采取正向的暗示，引导人们表现出最好的一面，消除会导致困窘愧疚的负面情境，如监狱、贫穷。换言之，斯金纳主张停止处罚。通过奖励的方式去规范人的行为。研究发现，奖励比惩罚更能促成人的行为。这点其实是显而易见的，没人喜欢惩罚，相比于做错事的惩罚，人们对做正确的事的奖励更加趋之若鹜。</p><p>当然，斯金纳的研究方式后来趋向于极端，他后来想要研究这种行为科学对人的影响，就把 女儿放在斯金纳箱里训练了两年，目的是观察人在可操作的条件下是否能训练出现在人无法 做到的事情。所以尽管斯纳金是一个十分爱子女，并充满人文主义精神的人，他的这种方法依然引发了巨大的争议。</p><p>但是，斯纳金的研究是十分有意义的，不但解释了我们做出愚蠢行为的原因，也被应用到很多地方。</p><blockquote><p>20世纪五六十年代，公立精神病院将斯金纳的行为理论应用于重度精神病人。例如，病人每举起汤匙吃一口饭菜，就能得到一根渴望已久的香烟，操作性条件反射原理让治愈无望的精神分裂症患者学会自己更衣进食。20世纪后期，临床学家也依据斯金纳操作性条件反射理论，有系统地使用脱敏法（desensitization）￼、满灌法（flooding）￼等技术，治疗恐惧症与焦虑症患者。这些行为疗法目前仍广为应用且效果显著。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学实验 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
