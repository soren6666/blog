<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/2021/07/21/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/21/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>这是我第一次发博客的学习文章，这个文章是我在学习git时做的笔记，为了弄懂我配了大量的图片，看完之后应该对git，github，版本控制都有一定的了解。当然这不是所谓的技术文章（事实上我现在也没能力去写技术文章），仅仅是把我的学习记录下来。文章是参考廖雪峰老师的git教程，和尚硅谷的git视频来写的。大家如果要学习的话建议去看看。</p><span id="more"></span><h2 id="git简介">git简介</h2><h3 id="版本控制">版本控制</h3><blockquote><p>什么是版本控制系统？</p><p>如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：</p><p>想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：</p><img src="https://i.loli.net/2021/07/21/pRkcDQsnYG82bv5.jpg" loading="lazy"><p>过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。</p><p>看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。</p><p>更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。</p><p>于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？</p><p>这个软件用起来就应该像这个样子，能记录每次文件的改动：</p><table><thead><tr><th style="text-align:left">版本</th><th style="text-align:left">文件名</th><th style="text-align:left">用户</th><th style="text-align:left">说明</th><th style="text-align:left">日期</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">service.doc</td><td style="text-align:left">张三</td><td style="text-align:left">删除了软件服务条款5</td><td style="text-align:left">7/12 10:38</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">service.doc</td><td style="text-align:left">张三</td><td style="text-align:left">增加了License人数限制</td><td style="text-align:left">7/12 18:09</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">service.doc</td><td style="text-align:left">李四</td><td style="text-align:left">财务部门调整了合同金额</td><td style="text-align:left">7/13 9:51</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">service.doc</td><td style="text-align:left">张三</td><td style="text-align:left">延长了免费升级周期</td><td style="text-align:left">7/14 15:17</td></tr></tbody></table><p>这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪</p></blockquote><h3 id="git概述">git概述</h3><p>git就是一个典型的版本控制工具。</p><p>它具有以下的作用：</p><ol><li>协同修改<ul><li>实现多人并行不悖的修改服务器端的同一个文件。</li></ul></li><li>数据备份<ul><li>git不仅能够保存目录和文件的当前状态，还能够保存每一个提交后的历史状态。</li></ul></li><li>版本管理<ul><li>git采用文件系统快照的形式，实现在保存每一个版本的文件信息时不保留重复数据，可以节约存储空间，提高运行效率。</li></ul></li><li>权限控制<ul><li>对团队中的开发人员进行权限控制。</li><li>对团队外开发者贡献的代码进行审核。</li></ul></li><li>历史记录<ul><li>查看修改人，修改时间，修改内容，日志信息</li><li>将本地文件恢复到某一个历史状态。</li></ul></li><li>分支管理<ul><li>允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。</li></ul></li></ol><h3 id="git优势">git优势</h3><ul><li>大部分操作都在本地完成，无需联网</li><li>能够保证版本信息的完整性（哈希操作）</li><li>尽可能的添加数据而不是删除或者修改（契合版本控制）</li><li>分支操作快捷流畅</li><li>与linux系统全面兼容</li></ul><h3 id="git安装">git安装</h3><p>具体的安装教程可以参考<a href="https://git-scm.com/doc">git官方文档</a>，有问题就去谷歌搜索一下（有困难找谷歌（斜眼笑））</p><h3 id="git结构">git结构</h3><img src="https://i.loli.net/2021/07/21/dFVSowqgktvM7OT.png" loading="lazy"><h3 id="git和代码托管中心">git和代码托管中心</h3><p>作用：用来维护远程库</p><ul><li>局域网环境下<ul><li>Gitlab服务器</li></ul></li><li>外网环境下<ul><li>GitHub</li><li>码云</li></ul></li></ul><h3 id="本地库和远程库">本地库和远程库</h3><p><strong>团队协作</strong></p><p>、<img src="/.com//zEM17gv2xkDRHAJ.png" loading="lazy"></p><p>**工作原理：**项目创建人将自己的本地库<code>push</code>到代码托管中心（远程库），任何人（有权限访问）可以将远程库<code>clone</code>到自己的本地库中，然后进行操作，但个人的修改不能直接上传到远程库，需要加入团队。然后将自己修改后的本地库<code>push</code>到远程库（由于使用git，会保留所有版本的记录），然后小组的其他成员将远程库<code>pull</code>回自己的本地库。从而实现团队之间的协同开发。</p><p><strong>跨团队协作</strong></p><img src="https://i.loli.net/2021/07/21/N29w6ZXtY3aPkSm.png" loading="lazy"><p>**工作原理：**对于团队外的成员，如果也想去参与团队的开发，可以<code>fork</code>该团队的远程库，将这个远程库传到自己的远程库中，再通过<code>clone</code>将远程库下载到本地库中，然后进行开发，再通过<code>push</code>将自己本地库<code>push</code>到自己的远程库中。然后向项目开发团队发送一个<code>push resquet</code>经由开发团队审核后可以传向开发团队的远程库，然后开发团队中的成员再<code>pull</code>到自己的本地库。</p><h2 id="git的命令行操作">git的命令行操作</h2><h3 id="本地库操作">本地库操作</h3><h4 id="本地库的初始化">本地库的初始化</h4><ul><li>命令：git init</li><li>操作：在Windows上任何一个窗口打开右键，选择Git Bash Here，即可打开命令行，使用git操作，也可使用linux操作。(<a href="https://app.yinxiang.com/shard/s22/nl/31392663/d8e60561-26ee-4794-b145-16428507c8e2">常见的linux命令</a>)找到文件后输入命令git init 对创建的文件进行初始化（效果就是创造一个.git的目录）</li><li><img src="https://i.loli.net/2021/07/21/9Ji6EPIuyA7dRfO.png" loading="lazy"></li><li>注意：.git目录中存放的是本地库相关的子目录和文件，不要删除，也不要随意的修改。</li></ul><h4 id="设置签名">设置签名</h4><ul><li><p>形式</p><p>用户名：tom</p><p>Email地址：goodmoring@tom.com作用：标识不同开发人员的身份</p><p>辨析：这里设置的签名和远程库登录账号没有任何关系</p><ul><li>作用：标识不同开发人员的身份</li><li>辨析：这里设置的签名和远程库登录账号没有任何关系</li><li>命令<ul><li>项目级别/仓库级别：尽在当前本地库范围内有效<ul><li>git config <a href="http://user.name">user.name</a> tom_pro</li><li>git config user.email <a href="mailto:goodMoring_pro@tom.com">goodMoring_pro@tom.com</a></li><li><img src="https://i.loli.net/2021/07/21/RaTXGsDwzqr92FP.png" loading="lazy"></li></ul></li><li>系统用户级别：登陆当前操作系统的用户范围（整个电脑）<ul><li>git config --global <a href="http://user.name">user.name</a> tom_glb</li><li>git config --global  user.email <a href="mailto:goodMoring_pro@tom.com">goodMoring_pro@tom.com</a></li><li>信息保存位置：.git/config文件</li><li><img src="https://i.loli.net/2021/07/21/ZdlJY7AbyRKjhNa.png" loading="lazy"></li></ul></li><li>级别优先级<ul><li>就近原则：项目级别优先与系统用户级别，二者都有时采用项目级别的签名</li><li>如果只有系统用户级别的签名，就以系统用户级别的签名为准</li><li>二者都没有不允许</li></ul></li></ul></li></ul></li></ul><h4 id="添加提交以及查看状态操作">添加提交以及查看状态操作</h4><h5 id="状态查看（查看暂存区的状态）"><strong>状态查看</strong>（查看暂存区的状态）</h5><p><strong>命令</strong> : <code>git status</code></p><p><strong>效果</strong>：</p><p>在git gash 中输入命令<code>git status</code>按下回车，执行效果如下</p><img src="https://i.loli.net/2021/07/21/CWzRGrIwtxhc9LM.jpg" loading="lazy"><p>使用vim 编辑器来创建一个good.txt[vim基本操作](onenote:<a href="https://d.docs.live.net/642c296afb78416e/%E6%96%87%E6%A1%A3/xx">https://d.docs.live.net/642c296afb78416e/文档/xx</a> 的笔记本/快速笔记.one#Linux vi/vim | 菜鸟教程&amp;section-id={553174BF-2230-45DE-B6C9-D1877DB35782}&amp;page-id={8FB29450-D071-47DE-87E3-7A9F269A254D}&amp;end) ([Web 视图](<a href="https://onedrive.live.com/view.aspx?resid=642C296AFB78416E!593&amp;id=documents&amp;wd=target">https://onedrive.live.com/view.aspx?resid=642C296AFB78416E!593&amp;id=documents&amp;wd=target</a>(快速笔记.one|553174BF-2230-45DE-B6C9-D1877DB35782%2FLinux vi%2Fvim | 菜鸟教程|8FB29450-D071-47DE-87E3-7A9F269A254D%2F)))!<img src="/.com//CWzRGrIwtxhc9LM.jpg" loading="lazy"></p><p>再次查看状态，显示有文件但未追踪，（鲜明的红色）</p><img src="/.com//eoA6Uzvf9LlWHbG.jpg" loading="lazy"><img src="https://i.loli.net/2021/07/21/1B7wsDg3WnxvSjQ.png" loading="lazy"><h5 id="提交到暂存区"><strong>提交到暂存区</strong></h5><p><strong>命令</strong>：<code>git add</code></p><p>使用git add命令将good.txt文件提交到暂存区</p><img src="/.com//eoA6Uzvf9LlWHbG.jpg" loading="lazy"><img src="https://i.loli.net/2021/07/21/1B7wsDg3WnxvSjQ.png" loading="lazy"><p>再次查看状态：</p><img src="/.com//gV1baJn6dUs75up.jpg" loading="lazy"><img src="https://i.loli.net/2021/07/21/yuBgsT2iZDO4UvS.png" loading="lazy"><p>提示 已经将文件提交到了暂存区（一抹舒服的绿色），同时提示可以用<code>git rm --cached &lt;file&gt;</code>这个命令将文件从暂存区中移除，效果如下</p><img src="https://i.loli.net/2021/07/21/GSzrAXw82yq3tWV.png" loading="lazy"><p>再次查看状态可以发现又回到了原来未追踪的状态、（即将暂存区的文件删除）</p><h5 id="提交到本地库"><strong>提交到本地库</strong></h5><p><strong>命令：</strong><code>git commit</code></p><p><strong>效果：</strong><img src="/.com//IP2bVGdAeDTBfFY.png" loading="lazy"></p><p>git提醒你去为你的这次提交输入信息（输入信息的注释）</p><p>使用vim编辑器输入要提交的注释</p><p><strong>效果：</strong><img src="/.com//CkGYiIm5ndqJrBV.png" loading="lazy"></p><p>在第四行是根提交（<code>root commit</code>）后面是你输入的信息</p><p>第五行显示的是文件的状态，一个文件被修改，三行的内容变化</p><p>再次输入<code>git status</code>，出现<img src="/.com//se2dzVvgK6NADJu.png" loading="lazy"></p><p>第三行的<code>nothing to commit</code>表示在暂存区中没有可以提交的文件而<code>working tree clean</code>字面意思，工作树是干净的，也是没有东西可提交的意思</p><p>使用vim编辑器对提交到本地库中的文件进行修改，加上一行的u</p><p>用<code>git status</code>查看状态</p><p><strong>效果：</strong><img src="/.com//dqD2Vyv4ONPxAFK.png" loading="lazy"></p><p>可以看到git已经检测到你的修改<code>modified</code>，git同样提示可以使用<code>git add</code> 命令去<code>update</code>（<strong>这里注意这个命令和没有提交时的名利有一点不同，之前是<code>track</code>，现在是<code>update</code>，一个是在未提交时追踪，一个是提交后更新</strong>（<strong><code>注意这里的提交是到暂存区而不是本地库</code></strong>））</p><p>git同时还提示可以使用<code>git restore</code>去重置回原来的版本</p><p>最后一行的<code>and/or</code>表示可以使用git add 先将文件提交到暂存区，然后<code>git commit</code>提交到本地库，或者使用<code>git commit -a </code>直接将其提交到本地库</p><p><strong>注</strong>：在提交文件到本地库的操作中 (<code>git commit</code>)，可以使用<code>git commit -m</code>命令直接在后面输入注释内容，无需再进入vim编辑器</p><p><strong>效果：</strong><img src="/.com//ONLEyrKIW69C8Rx.png" loading="lazy"></p><p>第二行由根目录变成了一个其他目录</p><p>第三行表示状态：有一行的内容被修改，一个文件有改变</p><h5 id="img-src-Git学习笔记-Mv5nDXeAmoWjxY4-png"><img src="/.com//Mv5nDXeAmoWjxY4.png" loading="lazy"></h5><h4 id="版本的前级和后退">版本的前级和后退</h4><p>版本的前进和后退是git实现项目管理的最重要的操作。</p><p>原理：git进行版本控制的原理主要是通过HEAD头指针的移动来实现的</p><h5 id="版本记录的查看"><strong>版本记录的查看</strong></h5><p><strong>命令</strong>：<code>git log</code></p><p><strong>效果：</strong><img src="/.com//SXY8lRx2FEWJgrs.png" loading="lazy"></p><p>可以从效果中看到提交的索引（commit 后面的一大串）和一个HEAD指针指向的分支（master）</p><p>还有就是作者，提交日期，以及提交时的注释。</p><h5 id="其他查看方法"><strong>其他查看方法</strong></h5><p><strong>命令</strong>：<code>git log -- pretty=one</code></p><p><strong>效果：</strong></p><img src="https://i.loli.net/2021/07/21/DiLdgzM3Hl4vEcA.png" loading="lazy"><p>将每次的信息缩减值一行</p><p><strong>命令:</strong><code>git log --oneline</code> (注意只能看见当前版本前的版本，无法回到以后的版本)</p><p><strong>效果：</strong><img src="/.com//DiLdgzM3Hl4vEcA.png" loading="lazy"></p><p>将索引的哈希链缩的更短、</p><p><strong>命令：</strong><code>git reflog</code>（最常用）</p><p><strong>效果：</strong><img src="https://i.loli.net/2021/07/21/ZcMvJHmGRLDrsK5.png" loading="lazy"><br><img src="/.com//y5lekuNOVRYQ1Ho.png" loading="lazy"></p><p>在oneline基础上显示移动至当前版本所需的步数</p><p>HEAD@{移动到当前版本所需的步数}</p><h5 id="版本的前进和后退的操作"><strong>版本的前进和后退的操作</strong></h5><h6 id="基于索引值操作"><strong>基于索引值操作</strong></h6><p><strong>命令：</strong><code>git reset --hard &lt;index&gt;</code></p><p><strong>效果：</strong><img src="/.com//CWeyXcMbuVLdGp7.png" loading="lazy"></p><p>在使用<code>git reflog</code>查看</p><p>!<img src="/.com//HBYbqzRpka9DnP1.png" loading="lazy"></p><p>可以看到指针已经指向了要索引的地址，即实现了版本的前进和后退操作</p><p>**注：**在输入索引值时，只要选中就进行了复制，可以直接粘贴下来</p><h6 id="使用-符号"><strong>使用<code>^</code>符号</strong></h6><p><strong>特点</strong>：只能后退</p><p>可以使用<code>git log --onelline</code>更加有效</p><img src="https://i.loli.net/2021/07/21/VCD68HgmhJe15Sx.png" loading="lazy"><p><strong>命令</strong>：<code>git reset --hard HEAD ^</code>注意一个<code>^</code>表示后退一个版本</p><img src="https://i.loli.net/2021/07/21/18ATYfpzLW2NaxX.png" loading="lazy"><h6 id="使用-符号-false2"><strong>使用<code>~</code>符号</strong></h6><p><strong>特点</strong>，同样只能用来回退</p><p>用法是将<code>^</code>符号的个数变成<code>~ &lt;number&gt;</code></p><p><strong>命令</strong>：<code>git reset --hard HEEAD ~n</code></p><h6 id="hard，soft，和mixed参数的区分"><strong>hard，soft，和mixed参数的区分</strong></h6><p>hard soft和mixed都是git reset命令的参数</p><p>首先介绍一个git命令：<code>git help</code>这是一个帮助命令，在后面可以输入操作命令去查看命令参数的描述，这个文档是在安装git时就内置在安装包里面的，使用 git help命令可以直接打开相应的文档查看、</p><p><strong>–soft</strong></p><p>文档描述</p><blockquote><p>Does not touch the <strong>index file</strong> or the <strong>working tree</strong> at all (but resets the head to <code>&lt;commit&gt;</code>, just like all modes do). This leaves all your changed files “Changes to be committed”, as <code>git status</code> would put it.</p></blockquote><p>看文档可以知道 <code>--soft</code> 参数不会去改变工作区和暂存区的内容，他改变的仅仅是本地库中的内容，下面来实际操作一下。</p><p>首先看一下没使用reset之前本地库的内容</p><img src="https://i.loli.net/2021/07/21/qT7wctH4bdYkeVL.png" loading="lazy"><p>然后看一下工作区的内容</p><img src="https://i.loli.net/2021/07/21/kdQBiq1rHVWCcDE.png" loading="lazy"><p>可以看到这里工作区和本地库的内容是一一对应的</p><p>然后我们使用<code>--soft</code>参数将本地库的内容索引到另一个版本</p><img src="https://i.loli.net/2021/07/21/7FHpzUADVGRQcoh.png" loading="lazy"><p>在使用<code>git reflog</code>查看本地库中的内容</p><img src="/.com//kdQBiq1rHVWCcDE.png" loading="lazy"><img src="https://i.loli.net/2021/07/21/2dei1zP9TgmVkMn.png" loading="lazy"><p>查看工作区</p><img src="https://i.loli.net/2021/07/21/kdQBiq1rHVWCcDE.png" loading="lazy"><p>可以看到本地库的指针已经发生变化，但工作区的内容仍未改变</p><p>用<code>git status</code>查看一下暂存区的状态</p><img src="https://i.loli.net/2021/07/21/yuBgsT2iZDO4UvS.png" loading="lazy"><p>看到的是绿色的内容，说明工作区和暂存区的内容是保持一致的</p><p>这里留个问题：为什么在改变本地库后，原来已经提交后的暂存区却能被<code>git status</code>找出来而且判断已经被修改了呢？</p><p><strong>–mixed</strong></p><p>文档描述</p><blockquote><p><strong>Resets the index but not the working tree</strong> (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action.</p></blockquote><blockquote><p>If <code>-N</code> is specified, removed paths are marked as intent-to-add (see <a href="git-add.html">git-add(1)</a>).</p></blockquote><p>可以看到<code>--mixed</code>参数改变的是本地库和暂存区的内容，但并没有改变工作区的内容，下面进行实操</p><img src="https://i.loli.net/2021/07/21/yuBgsT2iZDO4UvS.png" loading="lazy"><img src="/.com//qT7wctH4bdYkeVL.png" loading="lazy"><img src="https://i.loli.net/2021/07/21/kdQBiq1rHVWCcDE.png" loading="lazy"><p>在没有使用<code>git reset</code>时，一切还是保持老样子，工作区，暂存区和本地库是保持一致的</p><p>然后使用<code>--mixed</code>参数进行操作</p><img src="https://i.loli.net/2021/07/21/qFBDAfEWnYp7mjy.png" loading="lazy"><p>查看一下暂存区的状态</p><img src="https://i.loli.net/2021/07/21/LP71ASlvkgfzRhO.png" loading="lazy"><p>这里出现了红色的字，表示的是暂存区和工作区没有保持一致，也就是说，暂存区和本地库都改变了，但工作区没有变化、</p><p><strong>–hard</strong></p><p>文档描述</p><blockquote><p><strong>Resets the index and working tree.</strong> Any changes to tracked files in the working tree since <code>&lt;commit&gt;</code> are discarded.</p></blockquote><p>可以看出<code>--hard</code>参数是把三者都重置到了要重置的版本上、这个参数是十分快捷的，要想回退或前进版本，直接就可以使用这个参数，一步到位，不需要考虑暂存区，工作区是否也跟着前进和后退了，所以hard参数是最方便也是最常用的。</p><h6 id="删除文件的找回"><strong>删除文件的找回</strong></h6><p>在使用git时，如果不小心将文件从工作区删除了，也是可以用git找回的，但是有一个前提条件，就是必须把文件的操作信息存到本地库中去，也就是说，你在删除前使用<code>git add</code> 和 <code>git commit</code>将文件提交到了本地库。这样你就可以用版本回退的方式找回自己的文件。</p><p>因为内容和前面的回退操作比较相同，这里就不实际操作了，（主要是怕麻烦   斜眼笑.jpg）</p><p>但是可以看<a href="https://www.bilibili.com/video/BV1pW411A7a5?p=20">这个视频</a>，上面有详细的操作</p><h6 id="比较文件的差异"><strong>比较文件的差异</strong></h6><p>git是可以去比较不同版本之间文件的差异的，具体的命令是<code>git diff</code>，下面我就来实际操作一下。</p><p>首先，创建一个新的文档，提交到本地库</p><img src="https://i.loli.net/2021/07/21/4ohFcZSrasPYMGB.png" loading="lazy"><p>然后对该文档进行修改</p><img src="https://i.loli.net/2021/07/21/tIPdaRXpuG1zqFM.png" loading="lazy"><p>我修改了apple.txt文档，在第三行上加入了@@@@@</p><p>下面使用<code>git diff</code>命令去比较文档</p><img src="https://i.loli.net/2021/07/21/ZYnI7RkqzaDA9C8.png" loading="lazy"><p>可以看到使用<code>git diff</code>命令后，文档和<strong>暂存区</strong>的文档进行了比较，比较出了第三行少了一行apple ，但多了一行apple@@@@@。</p><p>红色的前面带的是<code>-</code>号，表示的是原文档与要比较的文档之间少的内容。</p><p>绿色的前面带的是<code>+</code>号，表示的是原文档与要比较的文档之间多的内容。</p><p>如果使用<code>git add</code>将文件提交到的暂存区，在使用<code>git diff</code>进行比较，是无法比较出差异的，这就说明了<code>git diff</code>这个命令在未加参数时表示的是与暂存区的比较</p><p><code>git diff</code>命令也可以和本地库的历史版本进行比较，这个后面需要加上HEAD的参数，表示与本地库中HEAD指针指向的版本之间进行比较。</p><img src="https://i.loli.net/2021/07/21/KPOIydciA893fW4.png" loading="lazy"><h4 id="git的分支">git的分支</h4><h6 id="为什么git会有分支"><strong>为什么git会有分支</strong></h6><p>在版本控制的过程中，会有多个项目同时推进的情况，这时候就要用到分支。</p><p>所以分支就是<strong>在版本控制中，使用多条线同时推进多个任务</strong>，下面用一个图来说明：</p><img src="https://i.loli.net/2021/07/21/jrfve4oM9qUOwgi.png" loading="lazy"><p>假设我们要开发一个项目，并且使用git作为我们版本控制的工具，开始我们会有一个master主干，我们的第一代项目在这个主干上。有了一代产品，我们就想在产品上多加一些新的功能。我们准备为我们的产品开发一个主题，于是我们就多了一条线，命名为feature_blue表示我们想去开发一个blue主题。然后我们将我们的主干上的版本拉到我们这条分支上，就是将master的版本复制到feature_blue上，这时两条线是互不干扰的，可以同时再进行开发，在blue线上，我们是基于主干上的一代进行开发的，在开发完成之后（开发过程中支线上可以有多个版本），在去把支线上的版本与主线上的版本进行合并。这样我们就基于一代的产品上开发出了带有blue主题的二代版本。同样的方法，我们可以再开一条线，为我们的版本开发出一个小游戏feature_game。</p><p>同时，分支对版本的修复与维护也十分方便。假设我们的产品现在出了个bug，我们可以开一条线hot_fix去修复bug，我们把master的内容拉到hot_fix上，然后在hot_fix上去进行修复，再将修复好的版本合并到master上，这样可以保证在主线项目正常运行的基础上去对其进行修复。</p><h6 id="分支的好处"><strong>分支的好处</strong></h6><ul><li>分支可以同时并行推进多个功能的开发，提高开发效率。</li><li>各个分支在开发过程中，如果一个分支开发失败，不会对其他分支有任何影响，失败的分支删除重新开始即可。</li></ul><h6 id="分支的实际操作"><strong>分支的实际操作</strong></h6><h6 id="分支的创建查看及转换"><strong>分支的创建查看及转换</strong></h6><p>首先用<code>git status</code>看一下</p><img src="https://i.loli.net/2021/07/21/hw82cimjJ6z9Vsf.png" loading="lazy"><p>可以看到git在刚创建是就会有一个主干分支master，而且现在就在这个master分支上，</p><p>我们可以使用<code>git branch -v</code>去查看在这个项目上所有的分支</p><p>使用<code>git branch </code>去创建一个新的分支hot_fix（<strong>注意创建好一个分支就已经把master分支上的项目复制过来了</strong>）</p><p>使用<code>git checkout </code>去转换分支</p><img src="https://i.loli.net/2021/07/21/NCzRFt6Kvb8Xx3G.png" loading="lazy"><img src="https://i.loli.net/2021/07/21/HXdV51PQBqLv8rF.png" loading="lazy"><h6 id="分支的合并"><strong>分支的合并</strong></h6><p>我们对hot_fix分支上的apple.txt文件进行了修改，在通过<code>git add </code> <code>git commit</code>把它提交到了本地库</p><p>这样hot_fix相对于master就快了一步，我们将hot_fix合并到master上。</p><ul><li>第一步：切换到接受修改的分支（被合并，要增加新内容）上<ul><li><code>git checkout</code>[被合并分支名]</li></ul></li><li>执行<code>merge</code>命令<ul><li><code>git merge</code>[有新内容的分支名]</li></ul></li></ul><img src="https://i.loli.net/2021/07/21/vRStxVhM2gXUI68.png" loading="lazy"><h6 id="冲突的解决"><strong>冲突的解决</strong></h6><p><strong>为什么会产生冲突</strong></p><p>分支在合并时，如果去合并的分支比被合并的分支进度快，而且前面的版本是相同的（相同文件的相同位置，并且内容一致），那么分支合并就是直接合并的（将要合并的版本合并到被合并的版本上，都变成了要合并的那个版本），但是如果合并之前的版本是不同（相同文件的相同位置，内容不一致）的，那么就会产生冲突，因为git无法判断哪一个版本要留下，这时git会发出提醒，让开发者去决定。</p><p>下面来实操一下</p><p>现在我们有两个分支，master和hot_fix，每个分支都用两个文件good.txt和apple.txt，我们使用vim编辑器去改变good.txt的内容，让他们中的同一行出现不同的输入。然后对他们进行merge合并</p><img src="https://i.loli.net/2021/07/21/Mb73cLICRAVTtKF.png" loading="lazy"><p>git提示自动合并失败，需要进行手动合并，并且最右边的（merge）变成了（master|MERGEING）</p><p>这时使用vim编辑器打开good.txt</p><img src="https://i.loli.net/2021/07/21/cNwi51YAnSC2Rto.png" loading="lazy"><p>发现good.txt里面多了几行，其中上面的</p><p>&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><p>bbbbbb edit by masteri</p><p>== == ==</p><p>表示的是要合并的分支（master）的冲突的内容</p><p>下面的表示的是去合并的分支（hot_fix）的从图的内容</p><p>这时可以再vim编辑器中直接去修改，最后得到最终版本即可</p><p>修改完成后用`git status查看一下状态</p><img src="https://i.loli.net/2021/07/21/FAWKYsL4UuTH9Vc.png" loading="lazy"><p>这时表示暂存区和工作区的文件不同，</p><p>可以用<code>git add</code> <code>git commit</code>去提交到本地库，<strong>注意在用<code>git commit</code>操作时后面不要跟文件名，否则会出现错误</strong></p><h4 id="git基本原理">git基本原理</h4><p>在介绍git的基本原理之前，先了解一个概念：<strong>哈希</strong></p><h6 id="哈希是什么呢"><strong>哈希是什么呢?</strong></h6><p>先看一下维基百科的定义</p><blockquote><p><strong>散列函数</strong>（英语：Hash function）又称<strong>散列算法</strong>、<strong>哈希函数</strong>，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>将数据打乱混合，重新创建一个叫做<strong>散列值</strong>（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。</p></blockquote><p>从上面的定义我们知道，哈希是通过一系列复杂的计算，将任何一种数据通过算法的计算输出成一种固定格式的数据。它具有以下特点：</p><img src="https://i.loli.net/2021/07/21/6m7VxeYzHTDAwvZ.png" loading="lazy"><p>因为这些特点，哈希具有很多用途。</p><p>最常用的是确保传输数据的准确性，如果数据在传输过程中出现了一点错误，那么使用同一种哈希算法的结果就会天差地别。因此可以通过哈希算法可以检验在数据传输过程中是否被篡改。</p><h6 id="git的数据存储机制"><strong>git的数据存储机制</strong></h6><img src="https://i.loli.net/2021/07/21/l5KyfAh6Dnge81W.png" loading="lazy"><h6 id="git的分支管理"><strong>git的分支管理</strong></h6><h4 id="远程库的操作">远程库的操作</h4><p>git远程库的操作主要是git和代码托管中心GitHub共同运行的。</p><p>所以我们要了解GitHub的相关操作。</p><h5 id="GitHub的注册"><strong>GitHub的注册</strong></h5><p>可以参见具体的<a href="https://docs.github.com/cn/github/getting-started-with-github/signing-up-for-github/signing-up-for-a-new-github-account">官方文档</a>  不过我相信这点肯定难不倒大家。</p><h5 id="GitHub的使用"><strong>GitHub的使用</strong></h5><p>我们先来回顾一下git协同开发的流程</p><blockquote><img src="/.com//image-20210711151558855.png" alt="image-20210711151558855" style="zoom: 25%;" loading="lazy"><p>**工作原理：**项目创建人将自己的本地库<code>push</code>到代码托管中心（远程库），任何人（有权限访问）可以将远程库<code>clone</code>到自己的本地库中，然后进行操作，但个人的修改不能直接上传到远程库，需要加入团队。然后将自己修改后的本地库<code>push</code>到远程库（由于使用git，会保留所有版本的记录），然后小组的其他成员将远程库<code>pull</code>回自己的本地库。从而实现团队之间的协同开发。</p><img src="/.com//image-20210711151842504.png" alt="image-20210711151842504" style="zoom:25%;" loading="lazy"><p>**工作原理：**对于团队外的成员，如果也想去参与团队的开发，可以<code>fork</code>该团队的远程库，将这个远程库传到自己的远程库中，再通过<code>clone</code>将远程库下载到本地库中，然后进行开发，再通过<code>push</code>将自己本地库<code>push</code>到自己的远程库中。然后向项目开发团队发送一个<code>push resquet</code>经由开发团队审核后可以传向开发团队的远程库，然后开发团队中的成员再<code>pull</code>到自己的本地库。</p></blockquote><p>依照这个流程我们梳理一下步骤</p><h5 id="对于团队开发">对于团队开发</h5><p>首先由项目创建人创建一个项目（本地库），然后通过<code>git init</code>    <code>git add</code>     <code>git commit </code>去提交到本地库，流程与前面没有差别，但这是使用的是全局化的签名，无需再设置新的项目签名。</p><h6 id="创建GitHub远程库"><strong>创建GitHub远程库</strong></h6><p>本地库创建好之后，我们需要设置远程库，具体的做法是在<a href="https://docs.github.com/cn/github/getting-started-with-github/quickstart/create-a-repo">GitHub上创建一个仓库</a>。</p><p>使用<code>git push</code>操作去将本地库push远程库</p><p>想要push操作，就一定要知道远程库的地址，在GitHub上创建地址后，我们可以在code哪里找到创建仓库的http和ssh地址，这个地址就是远程库的地址。</p><p>我们先用http地址连接到远程库</p><p>我们从code哪里将项目地址复制下来，但是网址很长，git提供了一个命令去给地址别名，</p><p>使用<code>git remote -v</code>查看地址的别名</p><p>使用 <code>git remote add &lt;别名&gt; &lt;地址&gt;</code></p><p>这是再次使用<code>git remote -v</code>查看，可以看到两个地址</p><img src="https://i.loli.net/2021/07/21/ytzwV6319emGIYQ.png" loading="lazy"><p>其中<code>fetch</code>用于取回，<code>push</code>用于推送</p><h6 id="向远程库推送">向远程库推送</h6><p>然后使用<code>git push</code>命令推送，注意推送时需要指出<strong>别名</strong>和要<strong>推送的分支</strong></p><img src="https://i.loli.net/2021/07/21/AN45p6IUJSyGXsh.png" loading="lazy"><p>按下回车键，这是会弹出GitHub登录的窗口，输入自己的GitHub账号</p><p>这样就把本地的修改推送到了远程库</p><h6 id="从远程库克隆">从远程库克隆</h6><p>那别人怎么将远程库clone到自己的本地库中呢？</p><p>我们可以使用<code>git clone &lt;地址&gt;</code>命令去将远程库克隆到本地库。</p><p>由于是读取操作，所以无需登陆账号</p><p>在执行完命令后，git会自动下载远程库中的内容，克隆出的本地库与远程库是一模一样的（包括文件，初始化，分支，和别名）</p><h6 id="团队之间的修改">团队之间的修改</h6><p>别人clone到本地库中做出修改，如果想要push到远程库，就需要项目创建人邀请加入团队。（具体的操作可以在google上查教程</p><p>）邀请成功后就可以将更新后的项目push到远程库了。</p><p>那么项目中的其他人可以将更新的版本<code>pull</code>到自己的本地库，</p><p><code>pull</code>有以下操作：</p><p><code>git fetch &lt;地址&gt; &lt;分支&gt;</code></p><p>fetch是不会直接修改本地库的文件，相当于把远程库的分支下载下来，</p><p>我们可以用<code>checkout</code>去检查。</p><p>然后使用<code>git merge&lt;地址别名|远程分支名&gt;</code></p><p>这两个操作和直接使用<code>git pull</code>命令是一样的。</p><p>这样同样会有另外的一个问题：怎样解决冲突?</p><p>如果双方修改了同一个项目同一个位置的不同内容，那么在往远程库push是就会发生冲突，GitHub默认是按照时间来判断的，也就是说如果两个人都开发了新版本，最快提交的会直接推送成功，而另一个如果有冲突就会push失败。这是就要把上一个人更新后的远程库pull到本地库，这是就会进入冲突状态，处理方法与前面处理分支方法类似。</p><h5 id="对于跨团队协作">对于跨团队协作</h5><p>不同团队之间共同开发时，只需要在GitHub上将远程库<code>fork</code>下来，这样就在自己的远程库中存储下了项目，修改就与前面完全相同。</p><p>如果想要提交到原开发团队，需要在GitHub上发出<code>pull request</code>，等待原项目创建负责人审核即可。</p><h2 id="结语">结语</h2><p>这个文章是我第一次写，无论是排版布局，还是内容深度，严谨性都有很多不足之处，而且配大量图算是一个失智之举，让这篇文章看起来十分冗杂，以后还是多用代码块来说明问题吧，这样不仅展示效果好，还附带有思考的空间。一味的将结果呈现出来，那是教程视频来干的事情，而不是博客文章。这篇算是一次试水，以后有时间我会将这些毛病改掉，给大家呈现出更精致，更适用的git笔记！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git|github </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/20/hello-world/"/>
      <url>/2021/07/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: [Deployment</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
